# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['data_cache']

package_data = \
{'': ['*']}

install_requires = \
['h5py>=2.10.0,<3.0.0', 'numpy', 'pandas>=1.0.0,<2.0.0', 'tables']

setup_kwargs = {
    'name': 'data-cache',
    'version': '0.1.5',
    'description': 'Data Cache',
    'long_description': '# Data cache\n\nWorks by hashing the combinations of arguments of a function call with\nthe function name to create a unique id of a table retrieval.  If\nthe function call is new the original function will be called, and the\nresulting tables(s) will be stored in a HDFStore indexed by the\nhashed key.  Next time the function is called with the same args the\ntables(s) will be retrieved from the store instead of executing the\nfunction.\n\nThe hashing of the arguments is done by first applying str() on the\nargument, and then taking th md5 hash of the combination of these args\ntogether with the function name.  This means that if a argument for\nsome reason does not have a str representation the key generation will\nfail.  To omit this issue one can specify which arguments the cache\nshould consider such that \'un-stringable\' arguments are skipped.  This\nfunctionality is also used for skipping arguments the should by design\nnot be considered for the key-generation like for example\ndatabase-clients.\n\n\n#### Setting cache file location\n\nThe module automatically creates a `cache/data.h5` relative to\n`__main__`, to change this set the environment variable\n`CACHE_PATH` to be the desired directory of the `data.h5` file.\n\n#### Disabling the cache with env-variable\n\nTo disable the cache set the environment variable\n`DISABLE_CACHE` to `TRUE`.\n\n### Usage\n\n#### Decorating functions\n\n```python\nfrom data_cache import pandas_cache\nfrom time import sleep\nfrom datetime import datetime\nimport pandas as pd\n\n@pandas_cache\ndef simple_func():\n    sleep(5)\n    return pd.DataFrame([[1,2,3], [2,3,4]])\n\n\nt0 = datetime.now()\nprint(simple_func())\nprint(datetime.now() - t0)\n\nt0 = datetime.now()\nprint(simple_func())\nprint(datetime.now() - t0)\n```\n```commandline\n   0  1  2\n0  1  2  3\n1  2  3  4\n0:00:05.343027\n   0  1  2\n0  1  2  3\n1  2  3  4\n0:00:00.015987\n```\n\n#### Decorating class methods\n\nThe decorator ignores arguments named \'self\' such that it will work across different instances of the same object.\n\n```python\nfrom data_cache import pandas_cache\nfrom time import sleep\nfrom datetime import datetime\nimport pandas as pd\n\n\nclass PandasClass:\n    def __init__(self):\n        print(self)\n\n    @pandas_cache\n    def simple_func(self):\n        sleep(5)\n        return pd.DataFrame([[1,2,3], [2,3,4]])\n\nc = PandasClass()\nt0 = datetime.now()\nprint(c.simple_func())\nprint(datetime.now() - t0)\n\nc = PandasClass()\nt0 = datetime.now()\nprint(c.simple_func())\nprint(datetime.now() - t0)\n```\n```commandline\n<__main__.PandasClass object at 0x003451F0>\n   0  1  2\n0  1  2  3\n1  2  3  4\n0:00:05.375342\n<__main__.PandasClass object at 0x124814B0>\n   0  1  2\n0  1  2  3\n1  2  3  4\n0:00:00.014959\n```\n\n#### Selecting arguments\n\n```python\nfrom data_cache import pandas_cache\nfrom time import sleep\nfrom datetime import datetime\nimport pandas as pd\n\n@pandas_cache("a", "c")\ndef simple_func(a, b, c=True):\n    sleep(5)\n    return pd.DataFrame([[1,2,3], [2,3,4]])\n\n\nt0 = datetime.now()\nprint(simple_func(a=1, b=2))\nprint(datetime.now() - t0)\n\n# b is not considered\nt0 = datetime.now()\nprint(simple_func(a=1, b=3))\nprint(datetime.now() - t0)\n```\n```commandline\n   0  1  2\n0  1  2  3\n1  2  3  4\n0:00:05.619620\n   0  1  2\n0  1  2  3\n1  2  3  4\n0:00:00.017980\n```\n\n#### Multi-DataFrame returns\n\n```python\nfrom data_cache import pandas_cache\nfrom time import sleep\nfrom datetime import datetime\nimport pandas as pd\n\n\n@pandas_cache("a", "c")\ndef simple_func(a, *args, **kwargs):\n    sleep(5)\n    return pd.DataFrame([[1,2,3], [2,3,4]]), pd.DataFrame([[1,2,3], [2,3,4]]) * 10\n\n\nt0 = datetime.now()\nprint(simple_func(1, b=2, c=True))\nprint(datetime.now() - t0)\n\nt0 = datetime.now()\nprint(simple_func(a=1, b=3, c=True))\nprint(datetime.now() - t0)\n```\n```commandline\n(   0  1  2\n0  1  2  3\n1  2  3  4,     0   1   2\n0  10  20  30\n1  20  30  40)\n0:00:05.368545\n(   0  1  2\n0  1  2  3\n1  2  3  4,     0   1   2\n0  10  20  30\n1  20  30  40)\n0:00:00.019578\n```\n\n#### Disabling cache for tests\n\nCaching can be disabled using the environment variable DISABLE_CACHE to TRUE\n\n```python\nfrom mock import patch\ndef test_cached_function():\n    with patch.dict("os.environ", {"DISABLE_CACHE": "TRUE"}, clear=True):\n        assert cached_function() == target\n```\n\n#### Numpy caching\n\n```python\nfrom data_cache import numpy_cache\nfrom time import sleep\nfrom datetime import datetime\nimport numpy as np\n\n\n@numpy_cache("a", "c")\ndef simple_func(a, *args, **kwargs):\n    sleep(5)\n    return np.array([[1, 2, 3], [2, 3, 4]]), np.array([[1, 2, 3], [2, 3, 4]]) * 10\n\n\nt0 = datetime.now()\nprint(simple_func(1, b=2, c=True))\nprint(datetime.now() - t0)\n\nt0 = datetime.now()\nprint(simple_func(a=1, b=3, c=True))\nprint(datetime.now() - t0)\n```\n\n```commandline\n(array([[1, 2, 3],\n       [2, 3, 4]]), array([[10, 20, 30],\n       [20, 30, 40]]))\n0:00:05.009084\n(array([[1, 2, 3],\n       [2, 3, 4]]), array([[10, 20, 30],\n       [20, 30, 40]]))\n0:00:00.002000\n```\n\n#### Metadata\n\nMetadata is automatically stored with the data on the group node containing the\nDataFrame/Array.\n\n```python\nfrom data_cache import numpy_cache, pandas_cache, read_metadata\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\n\n\n@pandas_cache\ndef function1(a, *args, b=1, **kwargs):\n    return pd.DataFrame()\n\n@numpy_cache\ndef function2(a, *args, b=1, **kwargs):\n    return np.array([])\n\nfunction1(1, True, datetime.date(2019, 11, 11))\nfunction2(2, False, b=2, c=1.1)\nread_metadata("path_to_data.h5")\n```\nresults:\n```json\n{\n    "/a86f0a323bf20998b5deda81e9f90bb49/a5d320e5dcdc5d3f35a4ca366980b2dc1": {\n        "a": "1",\n        "arglist": "(True, datetime.date(2019, 11, 11))",\n        "b": "1",\n        "date_stored": "01/05/2020, 10:00:00",\n        "function_name": "function1",\n        "module_path": "path_to_module"\n    },\n    "/a56ad8af46bc5fd8b9320b00b12e6c115/a62734531fc99855292c9db04d5eba60a": {\n        "a": "2",\n        "arglist": "(False,)",\n        "b": "2",\n        "c": "1.1",\n        "date_stored": "01/05/2020, 10:00:00",\n        "function_name": "function2",\n        "module_path":  "path_to_module"\n    }\n}\n```\n',
    'author': 'Statnett Datascience',
    'author_email': 'Datascience.Drift@statnett.no',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/statnett/data_cache',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6.1,<4.0.0',
}


setup(**setup_kwargs)
