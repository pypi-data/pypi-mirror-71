# coding: utf-8

"""
    Bleumi Pay REST API

    A simple and powerful REST API to integrate ERC-20, Ethereum, xDai, Algorand payments and/or payouts into your business or application  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: info@bleumi.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from bleumi_pay.models.payout import Payout  # noqa: F401,E501


class PayoutItemInputs(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'salt': 'str',
        'token': 'str',
        'payouts': 'list[Payout]'
    }

    attribute_map = {
        'salt': 'salt',
        'token': 'token',
        'payouts': 'payouts'
    }

    def __init__(self, salt=None, token=None, payouts=None):  # noqa: E501
        """PayoutItemInputs - a model defined in Swagger"""  # noqa: E501
        self._salt = None
        self._token = None
        self._payouts = None
        self.discriminator = None
        self.salt = salt
        self.token = token
        self.payouts = payouts

    @property
    def salt(self):
        """Gets the salt of this PayoutItemInputs.  # noqa: E501

        Unique identifier generated for the txid of the payout (specified during Create a Payout).  # noqa: E501

        :return: The salt of this PayoutItemInputs.  # noqa: E501
        :rtype: str
        """
        return self._salt

    @salt.setter
    def salt(self, salt):
        """Sets the salt of this PayoutItemInputs.

        Unique identifier generated for the txid of the payout (specified during Create a Payout).  # noqa: E501

        :param salt: The salt of this PayoutItemInputs.  # noqa: E501
        :type: str
        """
        if salt is None:
            raise ValueError("Invalid value for `salt`, must not be `None`")  # noqa: E501

        self._salt = salt

    @property
    def token(self):
        """Gets the token of this PayoutItemInputs.  # noqa: E501

        Token used for the payout  # noqa: E501

        :return: The token of this PayoutItemInputs.  # noqa: E501
        :rtype: str
        """
        return self._token

    @token.setter
    def token(self, token):
        """Sets the token of this PayoutItemInputs.

        Token used for the payout  # noqa: E501

        :param token: The token of this PayoutItemInputs.  # noqa: E501
        :type: str
        """
        if token is None:
            raise ValueError("Invalid value for `token`, must not be `None`")  # noqa: E501

        self._token = token

    @property
    def payouts(self):
        """Gets the payouts of this PayoutItemInputs.  # noqa: E501

        Array of payments to be made in this payout. This is an atomic transaction (i.e. either all payments are processed or all of them are rejected).  # noqa: E501

        :return: The payouts of this PayoutItemInputs.  # noqa: E501
        :rtype: list[Payout]
        """
        return self._payouts

    @payouts.setter
    def payouts(self, payouts):
        """Sets the payouts of this PayoutItemInputs.

        Array of payments to be made in this payout. This is an atomic transaction (i.e. either all payments are processed or all of them are rejected).  # noqa: E501

        :param payouts: The payouts of this PayoutItemInputs.  # noqa: E501
        :type: list[Payout]
        """
        if payouts is None:
            raise ValueError("Invalid value for `payouts`, must not be `None`")  # noqa: E501

        self._payouts = payouts

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PayoutItemInputs, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PayoutItemInputs):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
