# auto generated by update_py.py

import time
import queue
import threading
from datetime import datetime, timedelta
from tlclient.linker.timer import Timer


class TimerHelper:

    class PQueueItemWrapper():
        def __init__(self, tp, func):
            self._tp = tp
            self._func = func

        def __lt__(self, other):
            return self._tp < other._tp

    def __init__(self, logger, time_switchday: str = '17:30:00', time_morning_load: str = '08:36:00'):
        self._logger = logger
        self._time_switchday: str = time_switchday
        self._time_morning_load: str = time_morning_load
        self._timer_q = queue.PriorityQueue()
        self._timer_t = threading.Thread(
            target=self._timer_func, name='timer', daemon=True)
        self._timer_t.start()

    def _timer_func(self):
        is_switched = False
        while not self.is_stopped():
            now = datetime.now()
            if not self._timer_q.empty():
                item = self._timer_q.get()
                if now >= item._tp:
                    self._logger.info('process {} at {}'.format(item._func, item._tp))
                    item._func()
                    self._timer_q.task_done()
                else:
                    self._timer_q.put(item)
                    self._timer_q.task_done()
                    time.sleep(0.05)
            else:
                time.sleep(0.2)

            now = now.strftime('%H:%M:%S')
            if now < self._time_switchday:
                if is_switched and now >= self._time_morning_load:
                    is_switched = False
            else:
                if not is_switched:
                    self.on_switch_day()
                    is_switched = True

    @staticmethod
    def parse_nano(nano, format='%Y-%m-%d %H:%M:%S'):
        return Timer.nano_to_datetime(nano).strftime(format)

    def insert_func_at_next(self, tp, func):
        tp = datetime.strptime(tp, '%H:%M:%S')
        now = datetime.now()
        tp = datetime(year=now.year, month=now.month, day=now.day, hour=tp.hour, minute=tp.minute, second=tp.second)
        if now > tp:
            tp += timedelta(days=1)
        self._logger.info('got a job {} at {}'.format(func, tp))
        self._timer_q.put(self.PQueueItemWrapper(tp, func))

    def insert_func_after(self, elapsed, func):
        tp = datetime.now() + timedelta(seconds=elapsed)
        self._logger.info('got a job after {} seconds, at {}'.format(elapsed, tp))
        self._timer_q.put(self.PQueueItemWrapper(tp, func))

    # should be overrided
    def on_switch_day(self):
        pass
