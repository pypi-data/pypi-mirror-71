# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gridpp
else:
    import _gridpp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gridpp.delete_SwigPyIterator

    def value(self):
        return _gridpp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gridpp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gridpp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gridpp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gridpp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gridpp.SwigPyIterator_copy(self)

    def next(self):
        return _gridpp.SwigPyIterator_next(self)

    def __next__(self):
        return _gridpp.SwigPyIterator___next__(self)

    def previous(self):
        return _gridpp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gridpp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gridpp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gridpp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gridpp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gridpp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gridpp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gridpp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _gridpp:
_gridpp.SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.IntVector___nonzero__(self)

    def __bool__(self):
        return _gridpp.IntVector___bool__(self)

    def __len__(self):
        return _gridpp.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.IntVector___setitem__(self, *args)

    def pop(self):
        return _gridpp.IntVector_pop(self)

    def append(self, x):
        return _gridpp.IntVector_append(self, x)

    def empty(self):
        return _gridpp.IntVector_empty(self)

    def size(self):
        return _gridpp.IntVector_size(self)

    def swap(self, v):
        return _gridpp.IntVector_swap(self, v)

    def begin(self):
        return _gridpp.IntVector_begin(self)

    def end(self):
        return _gridpp.IntVector_end(self)

    def rbegin(self):
        return _gridpp.IntVector_rbegin(self)

    def rend(self):
        return _gridpp.IntVector_rend(self)

    def clear(self):
        return _gridpp.IntVector_clear(self)

    def get_allocator(self):
        return _gridpp.IntVector_get_allocator(self)

    def pop_back(self):
        return _gridpp.IntVector_pop_back(self)

    def erase(self, *args):
        return _gridpp.IntVector_erase(self, *args)

    def __init__(self, *args):
        _gridpp.IntVector_swiginit(self, _gridpp.new_IntVector(*args))

    def push_back(self, x):
        return _gridpp.IntVector_push_back(self, x)

    def front(self):
        return _gridpp.IntVector_front(self)

    def back(self):
        return _gridpp.IntVector_back(self)

    def assign(self, n, x):
        return _gridpp.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.IntVector_resize(self, *args)

    def insert(self, *args):
        return _gridpp.IntVector_insert(self, *args)

    def reserve(self, n):
        return _gridpp.IntVector_reserve(self, n)

    def capacity(self):
        return _gridpp.IntVector_capacity(self)
    __swig_destroy__ = _gridpp.delete_IntVector

# Register IntVector in _gridpp:
_gridpp.IntVector_swigregister(IntVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.FloatVector___nonzero__(self)

    def __bool__(self):
        return _gridpp.FloatVector___bool__(self)

    def __len__(self):
        return _gridpp.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.FloatVector___setitem__(self, *args)

    def pop(self):
        return _gridpp.FloatVector_pop(self)

    def append(self, x):
        return _gridpp.FloatVector_append(self, x)

    def empty(self):
        return _gridpp.FloatVector_empty(self)

    def size(self):
        return _gridpp.FloatVector_size(self)

    def swap(self, v):
        return _gridpp.FloatVector_swap(self, v)

    def begin(self):
        return _gridpp.FloatVector_begin(self)

    def end(self):
        return _gridpp.FloatVector_end(self)

    def rbegin(self):
        return _gridpp.FloatVector_rbegin(self)

    def rend(self):
        return _gridpp.FloatVector_rend(self)

    def clear(self):
        return _gridpp.FloatVector_clear(self)

    def get_allocator(self):
        return _gridpp.FloatVector_get_allocator(self)

    def pop_back(self):
        return _gridpp.FloatVector_pop_back(self)

    def erase(self, *args):
        return _gridpp.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _gridpp.FloatVector_swiginit(self, _gridpp.new_FloatVector(*args))

    def push_back(self, x):
        return _gridpp.FloatVector_push_back(self, x)

    def front(self):
        return _gridpp.FloatVector_front(self)

    def back(self):
        return _gridpp.FloatVector_back(self)

    def assign(self, n, x):
        return _gridpp.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _gridpp.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _gridpp.FloatVector_reserve(self, n)

    def capacity(self):
        return _gridpp.FloatVector_capacity(self)
    __swig_destroy__ = _gridpp.delete_FloatVector

# Register FloatVector in _gridpp:
_gridpp.FloatVector_swigregister(FloatVector)

class FloatVector3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.FloatVector3_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.FloatVector3___nonzero__(self)

    def __bool__(self):
        return _gridpp.FloatVector3___bool__(self)

    def __len__(self):
        return _gridpp.FloatVector3___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.FloatVector3___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.FloatVector3___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.FloatVector3___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.FloatVector3___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.FloatVector3___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.FloatVector3___setitem__(self, *args)

    def pop(self):
        return _gridpp.FloatVector3_pop(self)

    def append(self, x):
        return _gridpp.FloatVector3_append(self, x)

    def empty(self):
        return _gridpp.FloatVector3_empty(self)

    def size(self):
        return _gridpp.FloatVector3_size(self)

    def swap(self, v):
        return _gridpp.FloatVector3_swap(self, v)

    def begin(self):
        return _gridpp.FloatVector3_begin(self)

    def end(self):
        return _gridpp.FloatVector3_end(self)

    def rbegin(self):
        return _gridpp.FloatVector3_rbegin(self)

    def rend(self):
        return _gridpp.FloatVector3_rend(self)

    def clear(self):
        return _gridpp.FloatVector3_clear(self)

    def get_allocator(self):
        return _gridpp.FloatVector3_get_allocator(self)

    def pop_back(self):
        return _gridpp.FloatVector3_pop_back(self)

    def erase(self, *args):
        return _gridpp.FloatVector3_erase(self, *args)

    def __init__(self, *args):
        _gridpp.FloatVector3_swiginit(self, _gridpp.new_FloatVector3(*args))

    def push_back(self, x):
        return _gridpp.FloatVector3_push_back(self, x)

    def front(self):
        return _gridpp.FloatVector3_front(self)

    def back(self):
        return _gridpp.FloatVector3_back(self)

    def assign(self, n, x):
        return _gridpp.FloatVector3_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.FloatVector3_resize(self, *args)

    def insert(self, *args):
        return _gridpp.FloatVector3_insert(self, *args)

    def reserve(self, n):
        return _gridpp.FloatVector3_reserve(self, n)

    def capacity(self):
        return _gridpp.FloatVector3_capacity(self)
    __swig_destroy__ = _gridpp.delete_FloatVector3

# Register FloatVector3 in _gridpp:
_gridpp.FloatVector3_swigregister(FloatVector3)

class IntVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.IntVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.IntVector2___nonzero__(self)

    def __bool__(self):
        return _gridpp.IntVector2___bool__(self)

    def __len__(self):
        return _gridpp.IntVector2___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.IntVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.IntVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.IntVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.IntVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.IntVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.IntVector2___setitem__(self, *args)

    def pop(self):
        return _gridpp.IntVector2_pop(self)

    def append(self, x):
        return _gridpp.IntVector2_append(self, x)

    def empty(self):
        return _gridpp.IntVector2_empty(self)

    def size(self):
        return _gridpp.IntVector2_size(self)

    def swap(self, v):
        return _gridpp.IntVector2_swap(self, v)

    def begin(self):
        return _gridpp.IntVector2_begin(self)

    def end(self):
        return _gridpp.IntVector2_end(self)

    def rbegin(self):
        return _gridpp.IntVector2_rbegin(self)

    def rend(self):
        return _gridpp.IntVector2_rend(self)

    def clear(self):
        return _gridpp.IntVector2_clear(self)

    def get_allocator(self):
        return _gridpp.IntVector2_get_allocator(self)

    def pop_back(self):
        return _gridpp.IntVector2_pop_back(self)

    def erase(self, *args):
        return _gridpp.IntVector2_erase(self, *args)

    def __init__(self, *args):
        _gridpp.IntVector2_swiginit(self, _gridpp.new_IntVector2(*args))

    def push_back(self, x):
        return _gridpp.IntVector2_push_back(self, x)

    def front(self):
        return _gridpp.IntVector2_front(self)

    def back(self):
        return _gridpp.IntVector2_back(self)

    def assign(self, n, x):
        return _gridpp.IntVector2_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.IntVector2_resize(self, *args)

    def insert(self, *args):
        return _gridpp.IntVector2_insert(self, *args)

    def reserve(self, n):
        return _gridpp.IntVector2_reserve(self, n)

    def capacity(self):
        return _gridpp.IntVector2_capacity(self)
    __swig_destroy__ = _gridpp.delete_IntVector2

# Register IntVector2 in _gridpp:
_gridpp.IntVector2_swigregister(IntVector2)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _gridpp.DoubleVector___bool__(self)

    def __len__(self):
        return _gridpp.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _gridpp.DoubleVector_pop(self)

    def append(self, x):
        return _gridpp.DoubleVector_append(self, x)

    def empty(self):
        return _gridpp.DoubleVector_empty(self)

    def size(self):
        return _gridpp.DoubleVector_size(self)

    def swap(self, v):
        return _gridpp.DoubleVector_swap(self, v)

    def begin(self):
        return _gridpp.DoubleVector_begin(self)

    def end(self):
        return _gridpp.DoubleVector_end(self)

    def rbegin(self):
        return _gridpp.DoubleVector_rbegin(self)

    def rend(self):
        return _gridpp.DoubleVector_rend(self)

    def clear(self):
        return _gridpp.DoubleVector_clear(self)

    def get_allocator(self):
        return _gridpp.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _gridpp.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _gridpp.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _gridpp.DoubleVector_swiginit(self, _gridpp.new_DoubleVector(*args))

    def push_back(self, x):
        return _gridpp.DoubleVector_push_back(self, x)

    def front(self):
        return _gridpp.DoubleVector_front(self)

    def back(self):
        return _gridpp.DoubleVector_back(self)

    def assign(self, n, x):
        return _gridpp.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _gridpp.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _gridpp.DoubleVector_reserve(self, n)

    def capacity(self):
        return _gridpp.DoubleVector_capacity(self)
    __swig_destroy__ = _gridpp.delete_DoubleVector

# Register DoubleVector in _gridpp:
_gridpp.DoubleVector_swigregister(DoubleVector)

class FloatVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.FloatVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.FloatVector2___nonzero__(self)

    def __bool__(self):
        return _gridpp.FloatVector2___bool__(self)

    def __len__(self):
        return _gridpp.FloatVector2___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.FloatVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.FloatVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.FloatVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.FloatVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.FloatVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.FloatVector2___setitem__(self, *args)

    def pop(self):
        return _gridpp.FloatVector2_pop(self)

    def append(self, x):
        return _gridpp.FloatVector2_append(self, x)

    def empty(self):
        return _gridpp.FloatVector2_empty(self)

    def size(self):
        return _gridpp.FloatVector2_size(self)

    def swap(self, v):
        return _gridpp.FloatVector2_swap(self, v)

    def begin(self):
        return _gridpp.FloatVector2_begin(self)

    def end(self):
        return _gridpp.FloatVector2_end(self)

    def rbegin(self):
        return _gridpp.FloatVector2_rbegin(self)

    def rend(self):
        return _gridpp.FloatVector2_rend(self)

    def clear(self):
        return _gridpp.FloatVector2_clear(self)

    def get_allocator(self):
        return _gridpp.FloatVector2_get_allocator(self)

    def pop_back(self):
        return _gridpp.FloatVector2_pop_back(self)

    def erase(self, *args):
        return _gridpp.FloatVector2_erase(self, *args)

    def __init__(self, *args):
        _gridpp.FloatVector2_swiginit(self, _gridpp.new_FloatVector2(*args))

    def push_back(self, x):
        return _gridpp.FloatVector2_push_back(self, x)

    def front(self):
        return _gridpp.FloatVector2_front(self)

    def back(self):
        return _gridpp.FloatVector2_back(self)

    def assign(self, n, x):
        return _gridpp.FloatVector2_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.FloatVector2_resize(self, *args)

    def insert(self, *args):
        return _gridpp.FloatVector2_insert(self, *args)

    def reserve(self, n):
        return _gridpp.FloatVector2_reserve(self, n)

    def capacity(self):
        return _gridpp.FloatVector2_capacity(self)
    __swig_destroy__ = _gridpp.delete_FloatVector2

# Register FloatVector2 in _gridpp:
_gridpp.FloatVector2_swigregister(FloatVector2)

class DoubleVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.DoubleVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.DoubleVector2___nonzero__(self)

    def __bool__(self):
        return _gridpp.DoubleVector2___bool__(self)

    def __len__(self):
        return _gridpp.DoubleVector2___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.DoubleVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.DoubleVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.DoubleVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.DoubleVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.DoubleVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.DoubleVector2___setitem__(self, *args)

    def pop(self):
        return _gridpp.DoubleVector2_pop(self)

    def append(self, x):
        return _gridpp.DoubleVector2_append(self, x)

    def empty(self):
        return _gridpp.DoubleVector2_empty(self)

    def size(self):
        return _gridpp.DoubleVector2_size(self)

    def swap(self, v):
        return _gridpp.DoubleVector2_swap(self, v)

    def begin(self):
        return _gridpp.DoubleVector2_begin(self)

    def end(self):
        return _gridpp.DoubleVector2_end(self)

    def rbegin(self):
        return _gridpp.DoubleVector2_rbegin(self)

    def rend(self):
        return _gridpp.DoubleVector2_rend(self)

    def clear(self):
        return _gridpp.DoubleVector2_clear(self)

    def get_allocator(self):
        return _gridpp.DoubleVector2_get_allocator(self)

    def pop_back(self):
        return _gridpp.DoubleVector2_pop_back(self)

    def erase(self, *args):
        return _gridpp.DoubleVector2_erase(self, *args)

    def __init__(self, *args):
        _gridpp.DoubleVector2_swiginit(self, _gridpp.new_DoubleVector2(*args))

    def push_back(self, x):
        return _gridpp.DoubleVector2_push_back(self, x)

    def front(self):
        return _gridpp.DoubleVector2_front(self)

    def back(self):
        return _gridpp.DoubleVector2_back(self)

    def assign(self, n, x):
        return _gridpp.DoubleVector2_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.DoubleVector2_resize(self, *args)

    def insert(self, *args):
        return _gridpp.DoubleVector2_insert(self, *args)

    def reserve(self, n):
        return _gridpp.DoubleVector2_reserve(self, n)

    def capacity(self):
        return _gridpp.DoubleVector2_capacity(self)
    __swig_destroy__ = _gridpp.delete_DoubleVector2

# Register DoubleVector2 in _gridpp:
_gridpp.DoubleVector2_swigregister(DoubleVector2)

GRIDPP_VERSION = _gridpp.GRIDPP_VERSION
__version__ = _gridpp.__version__
OneToOne = _gridpp.OneToOne
r""" Continue past the end-points using a slope of 1"""
MeanSlope = _gridpp.MeanSlope
r""" Continue past the end-points using the mean slope of the curve"""
NearestSlope = _gridpp.NearestSlope
r""" Continue past the end-points using the slope of the two lowermost or uppermost points in the curve"""
Zero = _gridpp.Zero
r""" Continue past the end-points using a slope of 0"""
Mean = _gridpp.Mean
r""" Mean of values"""
Min = _gridpp.Min
r""" Minimum of values"""
Median = _gridpp.Median
r""" Mean of values"""
Max = _gridpp.Max
r""" Maximum of values"""
Quantile = _gridpp.Quantile
r""" A quantile from values"""
Std = _gridpp.Std
r""" Standard deviation of values"""
Variance = _gridpp.Variance
r""" Population variance of values"""
Sum = _gridpp.Sum
r""" Sum of values"""
Unknown = _gridpp.Unknown
r""" Unknown statistic"""

def get_statistic(name):
    r""" Convert name of a statistic enum"""
    return _gridpp.get_statistic(name)

def version():
    r"""
     The gridpp version
    :rtype: string
    :return: The gridpp version
    """
    return _gridpp.version()

def optimal_interpolation(bgrid, background, points, pobs, pratios, pbackground, structure, max_points):
    r"""
     Optimal interpolation for a deterministic field
    :type bgrid: :py:class:`Grid`
    :param bgrid: Grid of background field
    :type background: :py:class:`vec2`
    :param background: 2D field of background values
    :type points: :py:class:`Points`
    :param points: Points of observations
    :type pobs: :py:class:`vec`
    :param pobs: Vector of observations
    :type pratios: :py:class:`vec`
    :param pratios: Vector of ratio of observation error variance to background variance
    :type pbackground: :py:class:`vec`
    :param pbackground: Background with observation operator
    :type structure: :py:class:`StructureFunction`
    :param structure: Structure function
    :type max_points: int
    :param max_points: Maximum number of observations to use inside localization zone; Use 0 to disable
    """
    return _gridpp.optimal_interpolation(bgrid, background, points, pobs, pratios, pbackground, structure, max_points)

def optimal_interpolation_transform(bgrid, background, bsigma, points, pobs, psigma, pbackground, structure, max_points, transform):
    return _gridpp.optimal_interpolation_transform(bgrid, background, bsigma, points, pobs, psigma, pbackground, structure, max_points, transform)

def optimal_interpolation_ensi(bgrid, input, points, pobs, psigmas, pbackground, structure, max_points):
    r"""
     Optimal interpolation using a structure function based on an ensemble
    See Lussana et al 2019 (DOI: 10.1002/qj.3646)
    :type input: :py:class:`vec3`
    :param input: 3D field of background values (Y, X, E)
    :type bgrid: :py:class:`Grid`
    :param bgrid: grid corresponding to input
    :type pobs: :py:class:`vec`
    :param pobs: vector of observations
    :param pci: vector of ci values
    :type points: :py:class:`Points`
    :param points: observation points
    """
    return _gridpp.optimal_interpolation_ensi(bgrid, input, points, pobs, psigmas, pbackground, structure, max_points)

def neighbourhood(input, radius, statistic):
    r"""
     Spatial neighbourhood filter
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :type statistic: int
    :param statistic: Statistic to compute
    """
    return _gridpp.neighbourhood(input, radius, statistic)

def neighbourhood_ens(input, radius, statistic):
    r"""
     Neighbourhood filter in space and across ensemble members
    :type input: :py:class:`vec3`
    :param input: 3D vector with dimensions (Y, X, ensemble)
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :type statistic: int
    :param statistic: Statistic to compute
    """
    return _gridpp.neighbourhood_ens(input, radius, statistic)

def neighbourhood_quantile(input, quantile, radius):
    r"""
    Spatial neighbourhood filter. An exact but slow algorithm.
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :type quantile: float
    :param quantile: Quantile to calculate for (between 0 and 1)
    """
    return _gridpp.neighbourhood_quantile(input, quantile, radius)

def neighbourhood_quantile_ens(input, quantile, radius):
    r"""
    Neighbourhood filter in space and across ensemble members. An exampt but slow algorithm.
    :type input: :py:class:`vec3`
    :param input: 3D grid of values
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :type quantile: float
    :param quantile: Quantile to calculate for (between 0 and 1)
    """
    return _gridpp.neighbourhood_quantile_ens(input, quantile, radius)

def neighbourhood_quantile_fast(input, quantile, radius, thresholds):
    r"""
     Approximate spatial neighbourhood filter for quantile operation.
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type quantile: float
    :param quantile: Quantile to compute (between 0 and 1)
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :type thresholds: :py:class:`vec`
    :param thresholds: Vector of thresholds to use to approximate value
    """
    return _gridpp.neighbourhood_quantile_fast(input, quantile, radius, thresholds)

def neighbourhood_quantile_ens_fast(input, quantile, radius, thresholds):
    r"""
     Approximate neighbourhood filter space and across members for quantile operation
    :type input: :py:class:`vec3`
    :param input: 3D vector with dimensions (Y, X, ensemble)
    :type quantile: float
    :param quantile: Quantile to compute (between 0 and 1)
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :type thresholds: :py:class:`vec`
    :param thresholds: Vector of thresholds to use to approximate value
    """
    return _gridpp.neighbourhood_quantile_ens_fast(input, quantile, radius, thresholds)

def neighbourhood_brute_force(input, radius, statistic):
    r"""
    Spatial neighbourhood filter without any shortcuts. This is quite slow and is only useful for testing.
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type radius: int
    :param radius: Filter radius in number of gridpoints
    :param operation: one of min, mean, median, max
    """
    return _gridpp.neighbourhood_brute_force(input, radius, statistic)

def get_neighbourhood_thresholds(*args):
    r"""
    *Overload 1:*
    Calculate appropriate approximation thresholds for neighbourhood quantile
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type num_thresholds: int
    :param num_thresholds: Number of thresholds

    |

    *Overload 2:*
    Calculate appropriate approximation thresholds for neighbourhood quantile
    :type input: :py:class:`vec3`
    :param input: 3D grid of values
    :type num_thresholds: int
    :param num_thresholds: Number of thresholds
    """
    return _gridpp.get_neighbourhood_thresholds(*args)

def quantile_mapping(*args):
    r"""
    *Overload 1:*
     Quantile mapping of 2D grid using a constant quantile map
    :type input: :py:class:`vec2`
    :param input: Values on grid
    :type x: :py:class:`vec`
    :param x: X-axis parameters values
    :type y: :py:class:`vec`
    :param y: Y-axis parameters values
    :type policy: int
    :param policy: Extrapolation policy
    :rtype: :py:class:`vec2`
    :return: Quantile-mapped values

    |

    *Overload 2:*
     Quantile mapping of a vector of value
    :type input: :py:class:`vec`
    :param input: Input values
    :type x: :py:class:`vec`
    :param x: X-axis parameters values
    :type y: :py:class:`vec`
    :param y: Y-axis parameters values
    :type policy: int
    :param policy: Extrapolation policy
    :rtype: :py:class:`vec`
    :return: Quantile-mapped output values


    |

    *Overload 3:*
     Quantile mapping of a single value
    :type input: float
    :param input: Input value
    :param x: X-axis parameters values
    :param y: Y-axis parameters values
    :type policy: int
    :param policy: Extrapolation policy
    :rtype: float
    :return: Quantile-mapped output value
    """
    return _gridpp.quantile_mapping(*args)

def fill(igrid, input, points, radii, value, outside):
    r"""
     Fill in values inside or outside a set of circles
    :type input: :py:class:`vec2`
    :param input: Deterministic values with dimensions Y, X
    :param radiii: Circle radii for each point
    :type value: float
    :param value: Fill in this value
    :type outside: boolean
    :param outside: if True, fill outside circles, if False, fill inside circles
    """
    return _gridpp.fill(igrid, input, points, radii, value, outside)

def nearest(*args):
    return _gridpp.nearest(*args)

def bilinear(*args):
    r"""
    *Overload 1:*
     Bilinear downscaling grid to grid
    :type igrid: :py:class:`Grid`
    :param igrid: Input grid
    :type ogrid: :py:class:`Grid`
    :param ogrid: Output grid to downscale to
    :type ivalues: :py:class:`vec2`
    :param ivalues: 2D vector of values on the input grid
    :rtype: :py:class:`vec2`
    :return: Values on the output grid

    |

    *Overload 2:*
     Bilinear downscaling grid to points
    :type igrid: :py:class:`Grid`
    :param igrid: Input grid
    :param ogrid: Output points to downscale to
    :type ivalues: :py:class:`vec2`
    :param ivalues: 2D vector of values on the input grid
    :rtype: :py:class:`vec`
    :return: Values for the output points
    """
    return _gridpp.bilinear(*args)

def simple_gradient(*args):
    return _gridpp.simple_gradient(*args)

def wind_speed(*args):
    return _gridpp.wind_speed(*args)

def dewpoint(*args):
    r"""
    *Overload 1:*
    Calculate dewpoint temperature from temperature and relative humidity
    :type temperature: float
    :param temperature: Temperature [K]
    :type relative_humidity: float
    :param relative_humidity: Relative humidity [1]
    :rtype: float
    :return: Dewpoint temperature [K]

    |

    *Overload 2:*
    Vector version of dewpoint calculation
    :type temperature: :py:class:`vec`
    :param temperature: Temperatures [K]
    :type relative_humidity: :py:class:`vec`
    :param relative_humidity: Relative humidities [1]
    :rtype: :py:class:`vec`
    :return: Dewpoint temperatures [K]
    """
    return _gridpp.dewpoint(*args)

def relative_humidity(temperature, dewpoint):
    r"""
    Calculate relative humidity from temperature and dewpoint temperature
    :type temperature: float
    :param temperature: Temperature [K]
    :type dewpoint: float
    :param dewpoint: Dewpoint temperature [K]
    :rtype: float
    :return: Relative humidity [1]
    """
    return _gridpp.relative_humidity(temperature, dewpoint)

def wetbulb(temperature, pressure, relative_humidity):
    r"""
    Calculate wetbulb temperature from temperature, pressure, and relative humidity
    :type temperature: float
    :param temperature: Temperature [K]
    :type pressure: float
    :param pressure: Air pressure [pa]
    :param Relative: humidity [1]
    :rtype: float
    :return: Wetbulb temperature [K]
    """
    return _gridpp.wetbulb(temperature, pressure, relative_humidity)

def pressure(ielev, oelev, ipressure, itemperature=288.15):
    r"""
    Calculate pressure at a new elevation
    :type ielev: float
    :param ielev: Elevation at start point
    :type oelev: float
    :param oelev: Elevation at new point
    :type ipressure: float
    :param ipressure: Pressure at start point
    :type itemperature: float
    :param itemperature: Temperature at start point
    :rtype: float
    :return: Pressure at new point
    """
    return _gridpp.pressure(ielev, oelev, ipressure, itemperature)

def qnh(*args):
    r"""
    *Overload 1:*
    Diagnose QNH from pressure and altitude
    :type pressure: float
    :param pressure: Pressure at point [pa]
    :type altitude: float
    :param altitude: Altitude of point [m]
    :rtype: float
    :return: QNH [pa]

    |

    *Overload 2:*
    Vector version of QNH calculation
    :type pressure: :py:class:`vec`
    :param pressure: Pressures at points [pa]
    :type altitude: :py:class:`vec`
    :param altitude: Altitudes of points [m]
    :rtype: :py:class:`vec`
    :return: QNH [pa]
    """
    return _gridpp.qnh(*args)

def set_omp_threads(num):
    r""" Set the number of OpenMP threads to use. Overwrides OMP_NUM_THREAD env variable."""
    return _gridpp.set_omp_threads(num)

def initialize_omp():
    r""" Sets the number of OpenMP threads to 1 if OMP_NUM_THREADS undefined"""
    return _gridpp.initialize_omp()

def clock():
    r""" Helper functions"""
    return _gridpp.clock()

def debug(string):
    return _gridpp.debug(string)

def warning(string):
    return _gridpp.warning(string)

def error(string):
    return _gridpp.error(string)

def is_valid(value):
    return _gridpp.is_valid(value)

def calc_statistic(*args):
    return _gridpp.calc_statistic(*args)

def calc_quantile(*args):
    return _gridpp.calc_quantile(*args)

def num_missing_values(iArray):
    return _gridpp.num_missing_values(iArray)

def get_lower_index(iX, iValues):
    r"""
    Find the index in a vector that is equal or just below a value
    :type iX: float
    :param iX: Lookup value
    :type iValues: std::vector< float,std::allocator< float > >
    :param iValues: Lookup vector. Must be sorted.
    :rtype: int
    :return: The index into iValues that is equal or just below iX
    """
    return _gridpp.get_lower_index(iX, iValues)

def get_upper_index(iX, iValues):
    r"""
    Find the index in a vector that is equal or just above a value
    :type iX: float
    :param iX: Lookup value
    :type iValues: std::vector< float,std::allocator< float > >
    :param iValues: Lookup vector. Must be sorted.
    :rtype: int
    :return: The index into iValues that is equal or just above iX
    """
    return _gridpp.get_upper_index(iX, iValues)

def interpolate(x, iX, iY):
    r"""
    Piecewise linear interpolation.o
    If x is outside the range of iX, then the min/max value of iY is used
    :type x: float
    :param x: Interpolation to this point
    :type iX: std::vector< float,std::allocator< float > >
    :param iX: Vector of x-axis values. Vector must be sorted.
    :type iY: std::vector< float,std::allocator< float > >
    :param iY: Vector of y-axis values corresponding to iX.
    :rtype: float
    :return: Y value corresponding to x
    """
    return _gridpp.interpolate(x, iX, iY)

def not_implemented_error():
    return _gridpp.not_implemented_error()

def init_vec2(*args):
    r""" Initialize a vector of size Y, X, with a given value"""
    return _gridpp.init_vec2(*args)

def calc_even_quantiles(values, num):
    r"""
    Get reasonably spaced quantiles from a vector of values, ignoring duplicate values
    but including the first number after duplicated values. Include the lowest and highest
    values.
    :type values: :py:class:`vec`
    :param values: vector of values (unsorted, and no invalid values)
    :type num: int
    :param num: number of thresholds to get
    """
    return _gridpp.calc_even_quantiles(values, num)

def compatible_size(*args):
    return _gridpp.compatible_size(*args)

def test_array(v):
    r""" Special function whose presense is needed for SWIG"""
    return _gridpp.test_array(v)

def test_vec_input(input):
    r""" Testing function for 1D input vector"""
    return _gridpp.test_vec_input(input)

def test_ivec_input(input):
    r""" Testing function for 1D input vector"""
    return _gridpp.test_ivec_input(input)

def test_vec2_input(input):
    r""" Testing function for 2D input vector"""
    return _gridpp.test_vec2_input(input)

def test_vec3_input(input):
    r""" Testing function for 3D input vector"""
    return _gridpp.test_vec3_input(input)

def test_vec_output():
    r""" Testing function for 1D output vector"""
    return _gridpp.test_vec_output()

def test_vec2_output():
    r""" Testing function for 2D output vector"""
    return _gridpp.test_vec2_output()

def test_vec3_output():
    r""" Testing function for 3D output vector"""
    return _gridpp.test_vec3_output()

def test_ivec_output():
    r""" Testing function for 1D output vector"""
    return _gridpp.test_ivec_output()

def test_ivec2_output():
    return _gridpp.test_ivec2_output()
class Point(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.Point_swiginit(self, _gridpp.new_Point(*args))
    lat = property(_gridpp.Point_lat_get, _gridpp.Point_lat_set)
    lon = property(_gridpp.Point_lon_get, _gridpp.Point_lon_set)
    elev = property(_gridpp.Point_elev_get, _gridpp.Point_elev_set)
    laf = property(_gridpp.Point_laf_get, _gridpp.Point_laf_set)
    __swig_destroy__ = _gridpp.delete_Point

# Register Point in _gridpp:
_gridpp.Point_swigregister(Point)
cvar = _gridpp.cvar
MV = cvar.MV
MV_CML = cvar.MV_CML
pi = cvar.pi

class StructureFunction(object):
    r""" Covariance structure function"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def corr(self, p1, p2):
        r""" Correlation between two points"""
        return _gridpp.StructureFunction_corr(self, p1, p2)

    def localization_distance(self):
        r"""
         Maximum distance for which an observation can have an impact (localization)
        :rtype: float
        :return: Distance [m]
        """
        return _gridpp.StructureFunction_localization_distance(self)

    def clone(self):
        return _gridpp.StructureFunction_clone(self)
    __swig_destroy__ = _gridpp.delete_StructureFunction

# Register StructureFunction in _gridpp:
_gridpp.StructureFunction_swigregister(StructureFunction)

class BarnesStructure(StructureFunction):
    r""" Simple structure function based on distance, elevation, and land area fraction"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.BarnesStructure_swiginit(self, _gridpp.new_BarnesStructure(*args))

    def corr(self, p1, p2):
        return _gridpp.BarnesStructure_corr(self, p1, p2)

    def clone(self):
        return _gridpp.BarnesStructure_clone(self)
    __swig_destroy__ = _gridpp.delete_BarnesStructure

# Register BarnesStructure in _gridpp:
_gridpp.BarnesStructure_swigregister(BarnesStructure)

class CressmanStructure(StructureFunction):
    r""" Simple structure function based on distance, elevation, and land area fraction"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, h, v=0, w=0):
        _gridpp.CressmanStructure_swiginit(self, _gridpp.new_CressmanStructure(h, v, w))

    def corr(self, p1, p2):
        return _gridpp.CressmanStructure_corr(self, p1, p2)

    def clone(self):
        return _gridpp.CressmanStructure_clone(self)
    __swig_destroy__ = _gridpp.delete_CressmanStructure

# Register CressmanStructure in _gridpp:
_gridpp.CressmanStructure_swigregister(CressmanStructure)

class CrossValidation(StructureFunction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, structure, dist=0):
        _gridpp.CrossValidation_swiginit(self, _gridpp.new_CrossValidation(structure, dist))

    def corr(self, p1, p2):
        return _gridpp.CrossValidation_corr(self, p1, p2)

    def clone(self):
        return _gridpp.CrossValidation_clone(self)
    __swig_destroy__ = _gridpp.delete_CrossValidation

# Register CrossValidation in _gridpp:
_gridpp.CrossValidation_swigregister(CrossValidation)

class Transform(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def forward(self, *args):
        return _gridpp.Transform_forward(self, *args)

    def backward(self, *args):
        return _gridpp.Transform_backward(self, *args)
    __swig_destroy__ = _gridpp.delete_Transform

# Register Transform in _gridpp:
_gridpp.Transform_swigregister(Transform)

class Identity(Transform):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def forward(self, value):
        return _gridpp.Identity_forward(self, value)

    def backward(self, value):
        return _gridpp.Identity_backward(self, value)

    def __init__(self):
        _gridpp.Identity_swiginit(self, _gridpp.new_Identity())
    __swig_destroy__ = _gridpp.delete_Identity

# Register Identity in _gridpp:
_gridpp.Identity_swigregister(Identity)

class Log(Transform):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def forward(self, value):
        return _gridpp.Log_forward(self, value)

    def backward(self, value):
        return _gridpp.Log_backward(self, value)

    def __init__(self):
        _gridpp.Log_swiginit(self, _gridpp.new_Log())
    __swig_destroy__ = _gridpp.delete_Log

# Register Log in _gridpp:
_gridpp.Log_swigregister(Log)

class BoxCox(Transform):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, threshold):
        _gridpp.BoxCox_swiginit(self, _gridpp.new_BoxCox(threshold))

    def forward(self, value):
        return _gridpp.BoxCox_forward(self, value)

    def backward(self, value):
        return _gridpp.BoxCox_backward(self, value)
    __swig_destroy__ = _gridpp.delete_BoxCox

# Register BoxCox in _gridpp:
_gridpp.BoxCox_swigregister(BoxCox)

class KDTree(object):
    r""" Helper class for Grid and Points"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.KDTree_swiginit(self, _gridpp.new_KDTree(*args))

    def get_nearest_neighbour(self, lat, lon):
        r"""
        Find single nearest points
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        """
        return _gridpp.KDTree_get_nearest_neighbour(self, lat, lon)

    def get_neighbours(self, lat, lon, radius):
        r"""
        Find all points with a radius
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type radius: float
        :param radius: Lookup radius [m]
        """
        return _gridpp.KDTree_get_neighbours(self, lat, lon, radius)

    def get_neighbours_with_distance(self, lat, lon, radius, distances):
        r"""
        Find all points with a radius
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type radius: float
        :param radius: Lookup radius [m]
        :type distances: :py:class:`vec`
        :param distances: Vector to store separation distances [m]
        """
        return _gridpp.KDTree_get_neighbours_with_distance(self, lat, lon, radius, distances)

    def get_num_neighbours(self, lat, lon, radius):
        r"""
        Find the number of points within a radius
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type radius: float
        :param radius: Lookup radius [m]
        """
        return _gridpp.KDTree_get_num_neighbours(self, lat, lon, radius)

    def get_closest_neighbours(self, lat, lon, num):
        r"""
        Find a set of nearest points
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type num: int
        :param num: Number of points to find
        """
        return _gridpp.KDTree_get_closest_neighbours(self, lat, lon, num)

    @staticmethod
    def convert_coordinates(*args):
        r"""
        *Overload 1:*
        Convert lat/lons to 3D cartesian coordinates with the centre of the earth as the origin
        :type lats: :py:class:`vec`
        :param lats: vector of latitudes [deg]
        :type lons: :py:class:`vec`
        :param lons: vector of longitudes [deg]
        :type x_coords: :py:class:`vec`
        :param x_coords: vector of x-coordinates [m]
        :type y_coords: :py:class:`vec`
        :param y_coords: vector of y-coordinates [m]
        :type z_coords: :py:class:`vec`
        :param z_coords: vector of z-coordinates [m]


        |

        *Overload 2:*
        Same as above, but convert a single lat/lon to 3D cartesian coordinates
        :type lat: float
        :param lat: latitude [deg]
        :type lon: float
        :param lon: longitude [deg]
        :type x_coord: float
        :param x_coord: x-coordinate [m]
        :type y_coord: float
        :param y_coord: y-coordinate [m]
        :type z_coord: float
        :param z_coord: z-coordinate [m]
        """
        return _gridpp.KDTree_convert_coordinates(*args)

    @staticmethod
    def deg2rad(deg):
        return _gridpp.KDTree_deg2rad(deg)

    @staticmethod
    def rad2deg(deg):
        return _gridpp.KDTree_rad2deg(deg)

    @staticmethod
    def calc_distance(*args):
        return _gridpp.KDTree_calc_distance(*args)

    @staticmethod
    def calc_distance_fast(lat1, lon1, lat2, lon2):
        return _gridpp.KDTree_calc_distance_fast(lat1, lon1, lat2, lon2)

    def get_lats(self):
        return _gridpp.KDTree_get_lats(self)

    def get_lons(self):
        return _gridpp.KDTree_get_lons(self)

    def size(self):
        return _gridpp.KDTree_size(self)
    __swig_destroy__ = _gridpp.delete_KDTree

# Register KDTree in _gridpp:
_gridpp.KDTree_swigregister(KDTree)

def KDTree_convert_coordinates(*args):
    r"""
    *Overload 1:*
    Convert lat/lons to 3D cartesian coordinates with the centre of the earth as the origin
    :type lats: :py:class:`vec`
    :param lats: vector of latitudes [deg]
    :type lons: :py:class:`vec`
    :param lons: vector of longitudes [deg]
    :type x_coords: :py:class:`vec`
    :param x_coords: vector of x-coordinates [m]
    :type y_coords: :py:class:`vec`
    :param y_coords: vector of y-coordinates [m]
    :type z_coords: :py:class:`vec`
    :param z_coords: vector of z-coordinates [m]


    |

    *Overload 2:*
    Same as above, but convert a single lat/lon to 3D cartesian coordinates
    :type lat: float
    :param lat: latitude [deg]
    :type lon: float
    :param lon: longitude [deg]
    :type x_coord: float
    :param x_coord: x-coordinate [m]
    :type y_coord: float
    :param y_coord: y-coordinate [m]
    :type z_coord: float
    :param z_coord: z-coordinate [m]
    """
    return _gridpp.KDTree_convert_coordinates(*args)

def KDTree_deg2rad(deg):
    return _gridpp.KDTree_deg2rad(deg)

def KDTree_rad2deg(deg):
    return _gridpp.KDTree_rad2deg(deg)

def KDTree_calc_distance(*args):
    return _gridpp.KDTree_calc_distance(*args)

def KDTree_calc_distance_fast(lat1, lon1, lat2, lon2):
    return _gridpp.KDTree_calc_distance_fast(lat1, lon1, lat2, lon2)

class Points(object):
    r""" Represents a vector of locations and their metadata"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.Points_swiginit(self, _gridpp.new_Points(*args))

    def get_nearest_neighbour(self, lat, lon):
        return _gridpp.Points_get_nearest_neighbour(self, lat, lon)

    def get_neighbours(self, lat, lon, radius):
        return _gridpp.Points_get_neighbours(self, lat, lon, radius)

    def get_neighbours_with_distance(self, lat, lon, radius, distances):
        return _gridpp.Points_get_neighbours_with_distance(self, lat, lon, radius, distances)

    def get_num_neighbours(self, lat, lon, radius):
        return _gridpp.Points_get_num_neighbours(self, lat, lon, radius)

    def get_closest_neighbours(self, lat, lon, num):
        return _gridpp.Points_get_closest_neighbours(self, lat, lon, num)

    def get_lats(self):
        return _gridpp.Points_get_lats(self)

    def get_lons(self):
        return _gridpp.Points_get_lons(self)

    def get_elevs(self):
        return _gridpp.Points_get_elevs(self)

    def get_lafs(self):
        return _gridpp.Points_get_lafs(self)

    def size(self):
        return _gridpp.Points_size(self)

    def get_in_domain_indices(self, grid):
        return _gridpp.Points_get_in_domain_indices(self, grid)

    def get_in_domain(self, grid):
        return _gridpp.Points_get_in_domain(self, grid)
    __swig_destroy__ = _gridpp.delete_Points

# Register Points in _gridpp:
_gridpp.Points_swigregister(Points)

class Grid(object):
    r""" Represents a 2D grid of locations and their metadata"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.Grid_swiginit(self, _gridpp.new_Grid(*args))

    def get_nearest_neighbour(self, lat, lon):
        return _gridpp.Grid_get_nearest_neighbour(self, lat, lon)

    def get_neighbours(self, lat, lon, radius):
        return _gridpp.Grid_get_neighbours(self, lat, lon, radius)

    def get_neighbours_with_distance(self, lat, lon, radius, distances):
        return _gridpp.Grid_get_neighbours_with_distance(self, lat, lon, radius, distances)

    def get_num_neighbours(self, lat, lon, radius):
        return _gridpp.Grid_get_num_neighbours(self, lat, lon, radius)

    def get_closest_neighbours(self, lat, lon, num):
        return _gridpp.Grid_get_closest_neighbours(self, lat, lon, num)

    def get_lats(self):
        return _gridpp.Grid_get_lats(self)

    def get_lons(self):
        return _gridpp.Grid_get_lons(self)

    def get_elevs(self):
        return _gridpp.Grid_get_elevs(self)

    def get_lafs(self):
        return _gridpp.Grid_get_lafs(self)

    def size(self):
        return _gridpp.Grid_size(self)
    __swig_destroy__ = _gridpp.delete_Grid

# Register Grid in _gridpp:
_gridpp.Grid_swigregister(Grid)



