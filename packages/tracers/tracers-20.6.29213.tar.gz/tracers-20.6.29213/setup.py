# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['tracers', 'tracers.function']

package_data = \
{'': ['*']}

install_requires = \
['more-itertools==8.4.0']

setup_kwargs = {
    'name': 'tracers',
    'version': '20.6.29213',
    'description': 'Open-Source APM (Application monitoring) project that offers you zero overhead wrappers for profiling your code execution flow',
    'long_description': "# Table of contents\n\n- [Table of contents](#table-of-contents)\n- [Project description](#project-description)\n  * [Key Features](#key-features)\n- [Quick Introduction](#quick-introduction)\n- [Installation](#installation)\n- [Examples](#examples)\n\n# Project description\n\n**Tracers** is an Open-Source **APM** (Application monitoring) project\nthat offers you zero overhead wrappers for profiling your code execution flow\n\n```\nðŸ›ˆ  Finished transaction: 71b75b75d72743b882fe4f2205a451fd, 3.82 seconds\n\n  #    Timestamp       %     Total    Nested Call Chain\n\n     1     0.00s  100.0%     3.82s    âœ“ async function_a()\n     2     0.00s    2.7%     0.10s    Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n     3     0.10s   13.1%     0.50s    Â¦   âœ“ time.sleep(...)\n     4     0.60s   84.2%     3.21s    Â¦   âœ“ async function_b()\n     5     0.60s    2.7%     0.10s    Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n     6     0.70s   18.4%     0.70s    Â¦   Â¦   âœ“ async function_c()\n     7     0.70s    2.6%     0.10s    Â¦   Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n     8     0.81s   13.1%     0.50s    Â¦   Â¦   Â¦   âœ“ time.sleep(...)\n     9     1.31s    2.6%     0.10s    Â¦   Â¦   Â¦   âœ“ async function_d()\n    10     1.31s    2.6%     0.10s    Â¦   Â¦   Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n    11     1.41s   52.5%     2.00s    Â¦   Â¦   âœ“ time.sleep(...)\n    12     3.41s    2.6%     0.10s    Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n    13     3.51s    2.7%     0.10s    Â¦   Â¦   âœ“ async function_d()\n    14     3.51s    2.6%     0.10s    Â¦   Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n    15     3.61s    2.7%     0.10s    Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n    16     3.72s    2.6%     0.10s    Â¦   Â¦   âœ“ async function_e()\n    17     3.72s    2.6%     0.10s    Â¦   Â¦   Â¦   âœ“ async asyncio.tasks.sleep(delay, result=None, *, loop=None)\n\n  Some blocks (skews) occurred in the event loop Â¹\n\n  #    Timestamp     Delay\n\n     0     1.40s     2.00s\n     1     0.80s     0.50s\n     2     0.10s     0.50s\n\n  Â¹ Consider reviewing them carefully to improve the overall system throughput\n```\n\n## Key Features\n\n- Handles **any callable** object, which includes **your own code**,\n  **third party libraries**, and even the low-level **Python standard library**\n- Handles [**async**](https://docs.python.org/3/library/asyncio.html) code\n  **out-of-the box**, no config required\n- Exposes a **high-level API**:\n  - `@trace` decorator (which internally handles async/sync cases)\n- It's **Thread-safe**, **Async-safe**, **Process-safe** and **Context-safe**\n  - Accurate results in any scenario\n  - No worries about leaking, bleeding, corrupting, or locking stuff into other\n    code\n- Introduces **zero overhead** in production!\n  - The `@trace` decorator accepts a `do_trace` parameter\n    that you can dynamically set to `True` of `False` to differentiate\n    testing environments from production environments\n- It's **easy to deploy**\n  - No external dependencies!\n- It's easy to pin-point performance problems:\n  - Gives you the total execution time in seconds and **%**\n  - Allows you to identify points in time where your **async** event loop got blocked\n- Allows you to measure monotonic (wall time), process time, and thread time out-of-the box\n- Profiles without using dirty introspection stuff\n  - The main code is just 50 lines long, pretty high level, go and read it :)\n\n# Quick Introduction\n\nLet's start with a very basic example:\n\n```py\nimport time\nfrom dateutil.parser import parse\n\n\ndef example():\n    time.sleep(2.0)\n    your_business_logic('Sat Oct 11')\n\n\ndef your_business_logic(date: str):\n    parse(date)\n    time.sleep(1.0)\n\n\nexample()\n```\n\nTracing its flow and gathering profiling information is a matter of\ndecorating your functions:\n\n```diff\n--- a/examples/without_tracers.py\n+++ b/examples/with_tracers.py\n@@ -1,15 +1,18 @@\n import time\n from dateutil.parser import parse\n+from tracers.function import trace\n\n\n+@trace\n def example():\n     time.sleep(2.0)\n     your_business_logic('Sat Oct 11')\n\n\n+@trace\n def your_business_logic(date: str):\n     parse(date)\n     time.sleep(1.0)\n\n\n example()\n```\n\nIf you run it, all the functions you decorated will be traced\nand you'll have metrics of the execution flow:\n\n```\nðŸ›ˆ  Finished transaction: ce72c9dbe3d64e4cb43714fb87738ac4, 3.00 seconds\n\n  #    Timestamp      %     Total    Nested Call Chain\n\n     1     0.00s 100.0%     3.00s    âœ“ example()\n     2     2.00s  33.4%     1.00s    Â¦   âœ“ your_business_logic(date: str)\n```\n\nFrom the output you can conclude:\n- executing function *example* took a total of *3.0* seconds to complete\n- function *example* represents *100%* of your code time\n- function *example* called function: *your_business_logic*\n- function *your_business_logic* took *1.0* seconds out of the *3.0* seconds\n  the function *example* needed to complete\n- function *your_business_logic* represents *33.4%* of your execution time\n- There is *66.6%* of execution time\n  that we've not instrumented... yet!\n\nTracing code is not limited to your own code.\nYou can trace any **callable object** including **third party packages**,\n**Python's standard library**, and almost anything\n\nThe level of detail is up to you!\n\n\n```diff\n--- a/examples/with_tracers.py\n+++ b/examples/with_detailed_tracers.py\n@@ -1,18 +1,18 @@\n import time\n from dateutil.parser import parse\n from tracers.function import trace\n\n\n @trace\n def example():\n-    time.sleep(2.0)\n+    trace(time.sleep)(2.0)\n     your_business_logic('Sat Oct 11')\n\n\n @trace\n def your_business_logic(date: str):\n-    parse(date)\n-    time.sleep(1.0)\n+    trace(parse)(date)\n+    trace(time.sleep)(1.0)\n\n\n example()\n```\n\n```\nðŸ›ˆ  Finished transaction: 10b3878b12e647c1b326a9c55f954537, 3.00 seconds\n\n  #    Timestamp      %     Total    Nested Call Chain\n\n     1     0.00s 100.0%     3.00s    âœ“ example()\n     2     0.00s  66.6%     2.00s    Â¦   âœ“ time.sleep(...)\n     3     2.00s  33.4%     1.00s    Â¦   âœ“ your_business_logic(date: str)\n     4     2.00s   0.0%     0.00s    Â¦   Â¦   âœ“ dateutil.parser._parser.parse(timestr, parserinfo=None, **kwargs)\n     5     2.00s  33.3%     1.00s    Â¦   Â¦   âœ“ time.sleep(...)\n```\n\n# Installation\n\nWe are hosted on **PyPI**: https://pypi.org/project/tracers\n\nJust run: `pip install tracers`\nor use the package manager you like the most\n\n# Examples\n\nCheck them out in the\n[examples](https://github.com/kamadorueda/tracers/tree/master/examples)\nfolder\n",
    'author': 'Kevin Amado',
    'author_email': 'kamadorueda@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/kamadorueda/tracers',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
