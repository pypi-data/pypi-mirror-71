#!python

import os
import sys
import numpy as np
import pandas as pd
from glob import glob
import argparse
from astropy.time import Time

"""
A python version of the WQED Weld function for use
with the output from phot2lc.py
"""

# Generate arguments for command line parsing
parser = argparse.ArgumentParser(description='Provide Input & Output Filenames.')
parser.add_argument('-f', '--infiles',type=str,help="Search string for input files.")
parser.add_argument('-o', '--outfile',type=str,help="Output filename.")
parser.add_argument('-b', '--bjdref',type=float,default=0.0,
                                     help="Optional BJD reference time.")
args = parser.parse_args()

# Get list of filenames
filenames = sorted(glob(args.infiles))
Nf = len(filenames)
print('Welding {} Files:'.format(Nf))

# Get the BJD of T0 from header
bjds = []
names = []
facils = []
filts = []
for f in filenames:
    print("  {}".format(f))
    header = pd.read_csv(f,header=None,nrows=10,dtype=str).values

    # Grab Info From the Header
    name = header[0][0].split(":")[-1].strip()
    facil = header[1][0].split(":")[-1].strip()
    bjd = float(header[2][0].split(":")[-1].strip())
    filt = header[3][0].split(":")[-1].strip()
    bjds.append(bjd)
    names.append(name)
    facils.append(facil)
    filts.append(filt)

# Name Check
if not all(x == names[0] for x in names):
    print('WARNING:  Object names in headers do not all match.')


# Now Get all of the actual data
tdata = np.asarray([])  # Combined time data in BJD days
fdata = np.asarray([])
edata = np.asarray([])
for i,f in enumerate(filenames):
    data = np.loadtxt(f)
    tdata = np.concatenate((tdata,(data[:,0]/86400.0) + bjds[i]))
    fdata = np.concatenate((fdata,data[:,1]))
    edata = np.concatenate((edata,data[:,2]))

# Convert times in seconds to reference the minimum BJD
if args.bjdref == 0.0:
    refbjd = min(bjds)
else:
    refbjd = args.bjdref
tref = (tdata - refbjd) * 86400.0

# Resort and Reshape Arrays
Nv = len(tdata)
ind_sort = np.argsort(tref)
tsorted = np.reshape(tref[ind_sort],(Nv,1))
fsorted = np.reshape(fdata[ind_sort],(Nv,1))
esorted = np.reshape(edata[ind_sort],(Nv,1))

# Recombine into an output file
output = np.concatenate((tsorted,fsorted,esorted),axis=1)

# Create new header for output
lc_header = 'Object: {}'.format(names[0]) + \
          '\nFacilities/Instruments: {}'.format(facils[0]) + \
          '\nBJD_TDB of t_0: {:17.9f}'.format(refbjd) + \
          '\nFilter Used: {}'.format(filts[0]) + \
          '\nOptimal Aperture Radius: {}'.format('') + \
          '\nPoint-to-Point Scatter: {}'.format('') + \
          '\nComp Stars Used: {} {}'.format('','') + \
          '\nFit with Polynomial of Order: {}'.format('') + \
          '\nTotal Number of Points: {}'.format(Nv) + \
          '\nNumber of Points Removed: {}'.format('') + \
          '\nWelded Lightcurve Generated by Zach Vanderbosch on {}'.format(str(Time.now())[0:10]) + \
          '\nColumns: Mid-Exposure Time (s), Rel. Flux, Rel. Flux Error' 

# Save the lightcurve to file
lc_format = '%11.3f  %9.6f  %9.6f'
lc_fname = args.outfile
np.savetxt(lc_fname, output, fmt=lc_format, header=lc_header)











