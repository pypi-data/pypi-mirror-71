var pickle=pickle||{};pickle.Unpickler=class{constructor(e){this._reader=new pickle.Reader(e,0)}load(e,t){let p=this._reader,s=[],i=[],o=new Map;for(;p.position<p.length;){const c=p.byte();switch(c){case pickle.OpCode.PROTO:{const e=p.byte();if(e>4)throw new pickle.Error("Unsupported protocol version '"+e+"'.");break}case pickle.OpCode.GLOBAL:i.push([p.line(),p.line()].join("."));break;case pickle.OpCode.STACK_GLOBAL:i.push([i.pop(),i.pop()].reverse().join("."));break;case pickle.OpCode.PUT:{const e=parseInt(p.line(),10);o.set(e,i[i.length-1]);break}case pickle.OpCode.OBJ:{const t=i;i=s.pop(),i.push(e(t.pop(),t));break}case pickle.OpCode.GET:{const e=parseInt(p.line(),10);i.push(o.get(e));break}case pickle.OpCode.POP:i.pop();break;case pickle.OpCode.POP_MARK:i=s.pop();break;case pickle.OpCode.DUP:i.push(i[i.length-1]);break;case pickle.OpCode.PERSID:i.push(t(p.line()));break;case pickle.OpCode.BINPERSID:i.push(t(i.pop()));break;case pickle.OpCode.REDUCE:{const t=i.pop(),p=i.pop();i.push(e(p,t));break}case pickle.OpCode.NEWOBJ:{const t=i.pop(),p=i.pop();i.push(e(p,t));break}case pickle.OpCode.BINGET:i.push(o.get(p.byte()));break;case pickle.OpCode.LONG_BINGET:i.push(o.get(p.uint32()));break;case pickle.OpCode.BINPUT:o.set(p.byte(),i[i.length-1]);break;case pickle.OpCode.LONG_BINPUT:o.set(p.uint32(),i[i.length-1]);break;case pickle.OpCode.BININT:i.push(p.int32());break;case pickle.OpCode.BININT1:i.push(p.byte());break;case pickle.OpCode.LONG:i.push(parseInt(p.line(),10));break;case pickle.OpCode.BININT2:i.push(p.uint16());break;case pickle.OpCode.BINBYTES:i.push(p.bytes(p.int32()));break;case pickle.OpCode.SHORT_BINBYTES:i.push(p.bytes(p.byte()));break;case pickle.OpCode.FLOAT:i.push(parseFloat(p.line()));break;case pickle.OpCode.BINFLOAT:i.push(p.float64());break;case pickle.OpCode.INT:{const e=p.line();"01"==e?i.push(!0):"00"==e?i.push(!1):i.push(parseInt(e,10));break}case pickle.OpCode.EMPTY_LIST:case pickle.OpCode.EMPTY_TUPLE:case pickle.OpCode.EMPTY_SET:i.push([]);break;case pickle.OpCode.ADDITEMS:{const e=i;i=s.pop();let t=i[i.length-1];for(let p=0;p<e.length;p++)t.push(e[p]);break}case pickle.OpCode.DICT:{const e=i;i=s.pop();let t={};for(let p=0;p<e.length;p+=2)t[e[p]]=e[p+1];i.push(t);break}case pickle.OpCode.LIST:{const e=i;i=s.pop(),i.push(e);break}case pickle.OpCode.TUPLE:{const e=i;i=s.pop(),i.push(e);break}case pickle.OpCode.SETITEM:{const e=i.pop(),t=i.pop();let p=i[i.length-1];p.__setitem__?p.__setitem__(t,e):p[t]=e;break}case pickle.OpCode.SETITEMS:{const e=i;i=s.pop();let t=i[i.length-1];for(let p=0;p<e.length;p+=2)t.__setitem__?t.__setitem__(e[p],e[p+1]):t[e[p]]=e[p+1];break}case pickle.OpCode.EMPTY_DICT:i.push({});break;case pickle.OpCode.APPEND:{const e=i.pop();i[i.length-1].push(e);break}case pickle.OpCode.APPENDS:{const e=i;i=s.pop();let t=i[i.length-1];t.push.apply(t,e);break}case pickle.OpCode.STRING:{const e=p.line();i.push(e.substr(1,e.length-2));break}case pickle.OpCode.BINSTRING:i.push(p.string(p.uint32()));break;case pickle.OpCode.SHORT_BINSTRING:i.push(p.string(p.byte()));break;case pickle.OpCode.UNICODE:i.push(p.line());break;case pickle.OpCode.BINUNICODE:i.push(p.string(p.uint32(),"utf-8"));break;case pickle.OpCode.SHORT_BINUNICODE:i.push(p.string(p.byte(),"utf-8"));break;case pickle.OpCode.BUILD:{const e=i.pop();let t=i.pop();if(t.__setstate__)t.__setstate__.__call__?t.__setstate__.__call__([t,e]):t.__setstate__(e);else for(const p in e)t[p]=e[p];t.__read__&&(t=t.__read__(this)),i.push(t);break}case pickle.OpCode.MARK:s.push(i),i=[];break;case pickle.OpCode.NEWTRUE:i.push(!0);break;case pickle.OpCode.NEWFALSE:i.push(!1);break;case pickle.OpCode.LONG1:{const e=p.bytes(p.byte());let t=0;switch(e.length){case 0:t=0;break;case 1:t=e[0];break;case 2:t=e[1]<<8|e[0];break;case 3:t=e[2]<<16|e[1]<<8|e[0];break;case 4:t=e[3]<<24|e[2]<<16|e[1]<<8|e[0];break;default:t=Array.prototype.slice.call(e,0)}i.push(t);break}case pickle.OpCode.LONG4:i.push(p.bytes(p.uint32()));break;case pickle.OpCode.TUPLE1:i.push([i.pop()]);break;case pickle.OpCode.TUPLE2:{const e=i.pop(),t=i.pop();i.push([t,e]);break}case pickle.OpCode.TUPLE3:{const e=i.pop(),t=i.pop(),p=i.pop();i.push([p,t,e]);break}case pickle.OpCode.MEMOIZE:o.set(o.size,i[i.length-1]);break;case pickle.OpCode.FRAME:p.bytes(8);break;case pickle.OpCode.NONE:i.push(null);break;case pickle.OpCode.STOP:return i.pop();default:throw new pickle.Error("Unknown opcode '"+c+"'.")}}throw new pickle.Error("Unexpected end of file.")}read(e){return this._reader.bytes(e)}unescape(e,t){const p=e.length,s=new Uint8Array(p);if(t&&t==p){for(let p=0;p<t;p++)s[p]=e.charCodeAt(p);return s}let i=0,o=0;for(;i<p;){let t=e.charCodeAt(i++);if(92!==t||i>=p)s[o++]=t;else switch(t=e.charCodeAt(i++),t){case 39:s[o++]=39;break;case 92:s[o++]=92;break;case 34:s[o++]=34;break;case 114:s[o++]=13;break;case 110:s[o++]=10;break;case 116:s[o++]=9;break;case 98:s[o++]=8;break;case 88:case 120:{const t=i-1,c=o;for(let a=0;a<2;a++){if(i>=p){i=t,o=c,s[o]=92;break}let a=e.charCodeAt(i++);if(a=a>=65&&a<=70?a-55:a>=97&&a<=102?a-87:a>=48&&a<=57?a-48:-1,-1===a){i=t,o=c,s[o]=92;break}s[o]=s[o]<<4|a}o++;break}default:if(t<48||t>57)s[o++]=92,s[o++]=t;else{i--;let t=i,c=o;for(let a=0;a<3;a++){if(i>=p){i=t,o=c,s[o]=92;break}let a=e.charCodeAt(i++);if(a<48||a>57){i=t,o=c,s[o]=92;break}s[o]=s[o]<<3|a-48}o++}}}return s.slice(0,o)}},pickle.OpCode={MARK:40,EMPTY_TUPLE:41,STOP:46,POP:48,POP_MARK:49,DUP:50,BINBYTES:66,SHORT_BINBYTES:67,FLOAT:70,BINFLOAT:71,INT:73,BININT:74,BININT1:75,LONG:76,BININT2:77,NONE:78,PERSID:80,BINPERSID:81,REDUCE:82,STRING:83,BINSTRING:84,SHORT_BINSTRING:85,UNICODE:86,BINUNICODE:88,EMPTY_LIST:93,APPEND:97,BUILD:98,GLOBAL:99,DICT:100,APPENDS:101,GET:103,BINGET:104,LONG_BINGET:106,LIST:108,OBJ:111,PUT:112,BINPUT:113,LONG_BINPUT:114,SETITEM:115,TUPLE:116,SETITEMS:117,EMPTY_DICT:125,PROTO:128,NEWOBJ:129,TUPLE1:133,TUPLE2:134,TUPLE3:135,NEWTRUE:136,NEWFALSE:137,LONG1:138,LONG4:139,SHORT_BINUNICODE:140,BINUNICODE8:141,BINBYTES8:142,EMPTY_SET:143,ADDITEMS:144,FROZENSET:145,NEWOBJ_EX:146,STACK_GLOBAL:147,MEMOIZE:148,FRAME:149},pickle.Reader=class{constructor(e){e&&(this._buffer=e,this._dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),this._position=0),pickle.Reader._utf8Decoder=pickle.Reader._utf8Decoder||new TextDecoder("utf-8"),pickle.Reader._asciiDecoder=pickle.Reader._asciiDecoder||new TextDecoder("ascii")}get length(){return this._buffer.byteLength}get position(){return this._position}byte(){const e=this._position;return this.skip(1),this._dataView.getUint8(e)}bytes(e){const t=this._position;return this.skip(e),this._buffer.subarray(t,this._position)}uint16(){const e=this.position;return this.skip(2),this._dataView.getUint16(e,!0)}int32(){const e=this.position;return this.skip(4),this._dataView.getInt32(e,!0)}uint32(){const e=this.position;return this.skip(4),this._dataView.getUint32(e,!0)}float32(){const e=this.position;return this.skip(4),this._dataView.getFloat32(e,!0)}float64(){const e=this.position;return this.skip(8),this._dataView.getFloat64(e,!0)}skip(e){if(this._position+=e,this._position>this._buffer.length)throw new pickle.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}string(e,t){const p=this.bytes(e);return"utf-8"==t?pickle.Reader._utf8Decoder.decode(p):pickle.Reader._asciiDecoder.decode(p)}line(){const e=this._buffer.indexOf(10,this._position);if(-1==e)throw new pickle.Error("Could not find end of line.");const t=e-this._position,p=this.string(t,"ascii");return this.skip(1),p}},pickle.Error=class extends Error{constructor(e){super(e),this.name="Unpickle Error"}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.Unpickler=pickle.Unpickler);