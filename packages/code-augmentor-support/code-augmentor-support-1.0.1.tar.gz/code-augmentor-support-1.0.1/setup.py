# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['code_augmentor_support']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'code-augmentor-support',
    'version': '1.0.1',
    'description': 'Enables the use of Python 3 to write code generator scripts for Code Augmentor',
    'long_description': '# code-augmentor-support\n\nThis package enables the use of Python 3 as a scripting platform to generate code to serve the goals of Code Augmentor.\n\nCode Augmentor is a set of libraries, plugins and tools for bringing code generation techniques to every programmer. For a more detailed explanation please visit the main Code Augmentor Github repository [here](https://github.com/aaronicsubstances/code-augmentor).\n\nAs far as this package and Python 3 developers are concerned, it is enough to think of Code Augmentor as (1) a command-line application, (2) which is configured to run an [Apache Ant](https://ant.apache.org) XML build file, (3) which in turn runs a Python 3 package or project written by a programmer, (4) with the aim of generating code for Python 3 or  another target programming language, (5) using this package as a dependency.\n\n\n## Install\n\n`pip install code-augmentor-support`\n\n### Example\n\nBelow is a main script demonstrating how to set up the library for use with functions defined in two client modules snippets.py and worker.py.\n\nIt requires input and ouput file command-line arguments, and optional third argument to enable verbose logging.\n\n#### main.py\n\n```python\nimport os.path\nimport re\nimport sys\n\nfrom code_augmentor_support.tasks import ProcessCodeTask\n\nimport snippets\nimport worker\n\nFUNCTION_NAME_REGEX = re.compile(r\'^((snippets|worker)\\.)[a-zA-Z]\\w*$\')\ndef callUserFunction(functionName, augCode, context):\n    # validate name.\n    if not FUNCTION_NAME_REGEX.search(functionName):\n        raise Exception("Invalid/Unsupported function name: " + functionName)\n\n    # name is valid. make function call "dynamically".\n    result = eval(functionName + \'(augCode, context)\')\n    return result\n\ninstance = ProcessCodeTask()\ninstance.inputFile = sys.argv[1]\ninstance.outputFile = sys.argv[2]\nif len(sys.argv) > 3:\n    instance.verbose = bool(sys.argv[3])\ninstance.execute(callUserFunction)\nif instance.allErrors:\n    print(str(len(instance.allErrors)) + " error(s) found.", file=sys.stderr)\n    for errMsg in instance.allErrors:\n        print(errMsg, file=sys.stderr)\n    sys.exit(1)\n```\n\n#### snippets.py\n\n```python\ndef generateSerialVersionUID(augCode, context):\n    return "private static final int serialVersionUID = 23L;"\n```\n\n#### worker.py\n\n```python\ndef stringify(augCode, context):\n    g = context.newGenCode()\n    for i in range(len(augCode.args)):\n        s = \'"\' + augCode.args[i]\n        if i < len(augCode.args) - 1:\n            s += augCode.lineSeparator + \'" +\'\n        else:\n            s += \'"\'\n        g.contentParts.append(context.newContent(s, True))\n    return g\n```\n\n#### test-augCodes.json (sample input file)\n\n```json\n{ "genCodeStartDirective": "//:GS:", "genCodeEndDirective": "//:GE:", "embeddedStringDirective": "//:STR:", "embeddedJsonDirective": "//:JSON:", "skipCodeStartDirective": "//:SS:", "skipCodeEndDirective": "//:SE:", "augCodeDirective": "//:AUG_CODE:", "inlineGenCodeDirective": "//:GG:", "nestedLevelStartMarker": "[", "nestedLevelEndMarker": "]" }\n{"fileId":1,"dir":"src","relativePath":"A1.py","augmentingCodes":[{"id":1,"directiveMarker":"//:AUG_CODE:","indent":"","lineNumber":1,"lineSeparator":"\\n","nestedLevelNumber":0,"hasNestedLevelStartMarker":false,"hasNestedLevelEndMarker":false,"blocks":[{"stringify":false,"jsonify":false,"content":" snippets.generateSerialVersionUID "}]}]}\n{"fileId":2,"dir":"src","relativePath":"B2.py","augmentingCodes":[{"id":1,"directiveMarker":"//:AUG_CODE:","indent":"","lineNumber":1,"lineSeparator":"\\n","nestedLevelNumber":0,"hasNestedLevelStartMarker":false,"hasNestedLevelEndMarker":false,"blocks":[{"stringify":false,"jsonify":false,"content":" worker.stringify "},{"stringify":true,"jsonify":false,"content":" SELECT * FROM contacts "},{"stringify":true,"jsonify":false,"content":" WHERE contacts.id = ? "}]},{"id":2,"directiveMarker":"//:AUG_CODE:","indent":"","lineNumber":19,"lineSeparator":"\\n","nestedLevelNumber":0,"hasNestedLevelStartMarker":false,"hasNestedLevelEndMarker":false,"blocks":[{"stringify":false,"jsonify":false,"content":" snippets.generateSerialVersionUID "},{"stringify":false,"jsonify":true,"content":"{ \\"name\\": \\"expired\\", \\"type\\": \\"boolean\\" } "}]}]}\n\n```\n\n#### test-genCodes.json (expected output file)\n\n```json\n{}\n{"fileId":1,"generatedCodes":[{"id":1,"contentParts":[{"content":"private static final int serialVersionUID = 23L;","exactMatch":false}]}]}\n{"fileId":2,"generatedCodes":[{"id":1,"contentParts":[{"content":"\\" SELECT * FROM contacts \\n\\" +","exactMatch":true},{"content":"\\" WHERE contacts.id = ? \\"","exactMatch":true}]},{"id":2,"contentParts":[{"content":"private static final int serialVersionUID = 23L;","exactMatch":false}]}]}\n\n```\n\n## Usage\n\nThe library\'s functionality is contained in the method `execute` of the class `ProcessCodeTask` in the `tasks` module of this package. The `execute` method takes a function object used for evaluating code generation requests and producing generated code snippets.\n\nInstances of `ProcessCodeTask` have the following properties:\n\n   * `inputFile` - path to the code generation request. Must be the aug code file result of running the *code_aug_prepare* Ant task.\n   * `outputFile` - path for writing out code generation response. Will be used as the gen code file input to the *code_aug_complete* Ant task.\n   * `verbose` - boolean property which can be used with default verbose logging mechansim to enable printing of verbose mesages to standard output.\n   * `allErrors` - array which contains any errors encountered during execution.\n   \nThese methods can be overriden in a subclass:\n   * `logVerbose`, `logInfo`, `logWarn` - methods which are called with a format string, *args, and **kwargs, when a verbose message, normal message, or warning message is issued. By default all normal and warning messages are printed to standard output, and verbose messages are ignored.\n\nThe `evalFunction` function argument of the `execute` method is called with 3 arguments. The first is name of a function to invoke in the current Python scope, and the remaining two are an augmenting code object and a helper instance of the `ProcessCodeContext` class from the `models` module of this package. These remaining two arguments are the arguments passed to the function to be invoked.\n\nThe `evalFunction` is called with every augmenting code object encountered in the input file. It is expected to in turn call client-defined functions dynamically and receive from them a correponding generated code object to be written to the output file. As a convenience, it can return strings, content parts, and arrays of generated code objects.\n\n\n### Properties and Methods of `ProcessCodeContext` instances\n\n   * header - JSON object resulting from parsing first line of input file.\n   * globalScope - a readonly dictionary provided for use by clients which remains throughout parsing of entire input file.\n   * fileScope - an dictionary provided for use by clients which is reset at the start of processing every line of input file.\n   * fileAugCodes - JSON object resulting of parsing current line of input file other than first line.\n   * augCodeIndex - index of `augCode` parameter in `fileAugCodes.augmentingCodes` array\n   * newGenCode() - convenience method available to clients for creating a generated code object with empty `contentParts` array property.\n   * newContent(content, exactMatch=false) - convenience method available to clients for creating a new content part object with properties set with arguments supplied to the function.\n\n## Note on JSON serialization\n\nThis library deserializes JSON objects into instances of the class `types.SimpleNamespace`. It similarly requires objects to be serialized to be either dictionaries or instances of `types.SimpleNamespace`. \n\nBy so doing clients are provided with the convenience that any arbitrary field can be set on a JSON object, and it will get serialized. \n\nThe default Python behaviour will apply though, when trying to access non-existent fields on a deserialized JSON object by raising an error. In that case, the function `hasattr` will have to be called first.\n\n## Further Information\n\nFor more information on the structure of augmenting code object, generated code object and other considerations, refer to [wiki](https://github.com/aaronicsubstances/code-augmentor/wiki/Documentation-for-Code-Generator-Scripts) in the main Code Augmentor repository.\n',
    'author': 'Aaron Baffour-Awuah',
    'author_email': 'aaronbaffourawuah@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/aaronicsubstances/code-augmentor#readme',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.5,<4.0',
}


setup(**setup_kwargs)
