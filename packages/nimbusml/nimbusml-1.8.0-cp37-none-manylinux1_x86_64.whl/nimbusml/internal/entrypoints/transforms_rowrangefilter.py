# - Generated by tools/entrypoint_compiler.py: do not edit by hand
"""
Transforms.RowRangeFilter
"""

import numbers

from ..utils.entrypoints import EntryPoint
from ..utils.utils import try_set, unlist


def transforms_rowrangefilter(
        column,
        data,
        output_data=None,
        model=None,
        min=None,
        max=None,
        complement=False,
        include_min=True,
        include_max=None,
        **params):
    """
    **Description**
        Filters a dataview on a column of type Single, Double or Key
        (contiguous). Keeps the values that are in the specified
        min/max range. NaNs are always filtered out. If the input is
        a Key type, the min/max are considered percentages of the
        number of values.

    :param column: Column (inputs).
    :param data: Input dataset (inputs).
    :param min: Minimum value (0 to 1 for key types) (inputs).
    :param max: Maximum value (0 to 1 for key types) (inputs).
    :param complement: If true, keep the values that fall outside the
        range. (inputs).
    :param include_min: If true, include in the range the values that
        are equal to min. (inputs).
    :param include_max: If true, include in the range the values that
        are equal to max. (inputs).
    :param output_data: Transformed dataset (outputs).
    :param model: Transform model (outputs).
    """

    entrypoint_name = 'Transforms.RowRangeFilter'
    inputs = {}
    outputs = {}

    if column is not None:
        inputs['Column'] = try_set(
            obj=column,
            none_acceptable=False,
            is_of_type=str,
            is_column=True)
    if data is not None:
        inputs['Data'] = try_set(
            obj=data,
            none_acceptable=False,
            is_of_type=str)
    if min is not None:
        inputs['Min'] = try_set(
            obj=min,
            none_acceptable=True,
            is_of_type=numbers.Real)
    if max is not None:
        inputs['Max'] = try_set(
            obj=max,
            none_acceptable=True,
            is_of_type=numbers.Real)
    if complement is not None:
        inputs['Complement'] = try_set(
            obj=complement,
            none_acceptable=True,
            is_of_type=bool)
    if include_min is not None:
        inputs['IncludeMin'] = try_set(
            obj=include_min,
            none_acceptable=True,
            is_of_type=bool)
    if include_max is not None:
        inputs['IncludeMax'] = try_set(
            obj=include_max,
            none_acceptable=True,
            is_of_type=bool)
    if output_data is not None:
        outputs['OutputData'] = try_set(
            obj=output_data,
            none_acceptable=False,
            is_of_type=str)
    if model is not None:
        outputs['Model'] = try_set(
            obj=model,
            none_acceptable=False,
            is_of_type=str)

    input_variables = {
        x for x in unlist(inputs.values())
        if isinstance(x, str) and x.startswith("$")}
    output_variables = {
        x for x in unlist(outputs.values())
        if isinstance(x, str) and x.startswith("$")}

    entrypoint = EntryPoint(
        name=entrypoint_name, inputs=inputs, outputs=outputs,
        input_variables=input_variables,
        output_variables=output_variables)
    return entrypoint
