{"version":3,"file":"chunk.ab96942901cd9a8d7754.js","sources":["webpack:///./src/components/dialog/ha-iron-focusables-helper.js","webpack:///./src/common/search/search-input.ts","webpack:///./src/panels/lovelace/editor/card-editor/hui-card-picker.ts","webpack:///./src/panels/lovelace/editor/card-editor/hui-card-editor.ts","webpack:///./src/panels/lovelace/editor/card-editor/hui-dialog-edit-card.ts"],"sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n/*\n  Fixes issue with not using shadow dom properly in iron-overlay-behavior/icon-focusables-helper.js\n*/\nimport { IronFocusablesHelper } from \"@polymer/iron-overlay-behavior/iron-focusables-helper\";\nimport { dom } from \"@polymer/polymer/lib/legacy/polymer.dom\";\n\nexport const HaIronFocusablesHelper = {\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the chidren,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  getTabbableNodes: function (node) {\n    var result = [];\n    // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n    var needsSortByTabIndex = this._collectTabbableNodes(node, result);\n    if (needsSortByTabIndex) {\n      return IronFocusablesHelper._sortByTabIndex(result);\n    }\n    return result;\n  },\n\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result`\n   * if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n  _collectTabbableNodes: function (node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (\n      node.nodeType !== Node.ELEMENT_NODE ||\n      !IronFocusablesHelper._isVisible(node)\n    ) {\n      return false;\n    }\n    var element = /** @type {!HTMLElement} */ (node);\n    var tabIndex = IronFocusablesHelper._normalizedTabIndex(element);\n    var needsSort = tabIndex > 0;\n    if (tabIndex >= 0) {\n      result.push(element);\n    }\n\n    // In ShadowDOM v1, tab order is affected by the order of distrubution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distrubution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.\n    var children;\n    if (element.localName === \"content\" || element.localName === \"slot\") {\n      children = dom(element).getDistributedNodes();\n    } else {\n      // /////////////////////////\n      // Use shadow root if possible, will check for distributed nodes.\n      // THIS IS THE CHANGED LINE\n      children = dom(element.shadowRoot || element.root || element).children;\n      // /////////////////////////\n    }\n    for (var i = 0; i < children.length; i++) {\n      // Ensure method is always invoked to collect tabbable children.\n      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n    }\n    return needsSort;\n  },\n};\n","import \"@polymer/paper-input/paper-input\";\nimport {\n  css,\n  CSSResult,\n  customElement,\n  LitElement,\n  property,\n} from \"lit-element\";\nimport { html, TemplateResult } from \"lit-html\";\nimport { classMap } from \"lit-html/directives/class-map\";\nimport \"../../components/ha-svg-icon\";\nimport { fireEvent } from \"../dom/fire_event\";\nimport { mdiMagnify, mdiClose } from \"@mdi/js\";\nimport \"@material/mwc-icon-button/mwc-icon-button\";\n\n@customElement(\"search-input\")\nclass SearchInput extends LitElement {\n  @property() public filter?: string;\n\n  @property({ type: Boolean, attribute: \"no-label-float\" })\n  public noLabelFloat? = false;\n\n  @property({ type: Boolean, attribute: \"no-underline\" })\n  public noUnderline = false;\n\n  @property({ type: Boolean })\n  public autofocus = false;\n\n  public focus() {\n    this.shadowRoot!.querySelector(\"paper-input\")!.focus();\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <style>\n        .no-underline:not(.focused) {\n          --paper-input-container-underline: {\n            display: none;\n            height: 0;\n          }\n        }\n      </style>\n      <paper-input\n        class=${classMap({ \"no-underline\": this.noUnderline })}\n        .autofocus=${this.autofocus}\n        label=\"Search\"\n        .value=${this.filter}\n        @value-changed=${this._filterInputChanged}\n        .noLabelFloat=${this.noLabelFloat}\n      >\n        <ha-svg-icon\n          path=${mdiMagnify}\n          slot=\"prefix\"\n          class=\"prefix\"\n        ></ha-svg-icon>\n        ${this.filter &&\n        html`\n          <mwc-icon-button\n            slot=\"suffix\"\n            class=\"suffix\"\n            @click=${this._clearSearch}\n            alt=\"Clear\"\n            title=\"Clear\"\n          >\n            <ha-svg-icon path=${mdiClose}></ha-svg-icon>\n          </mwc-icon-button>\n        `}\n      </paper-input>\n    `;\n  }\n\n  private async _filterChanged(value: string) {\n    fireEvent(this, \"value-changed\", { value: String(value) });\n  }\n\n  private async _filterInputChanged(e) {\n    this._filterChanged(e.target.value);\n  }\n\n  private async _clearSearch() {\n    this._filterChanged(\"\");\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      ha-svg-icon,\n      mwc-icon-button {\n        color: var(--primary-text-color);\n      }\n      mwc-icon-button {\n        --mdc-icon-button-size: 24px;\n      }\n      ha-svg-icon.prefix {\n        margin: 8px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"search-input\": SearchInput;\n  }\n}\n","import Fuse from \"fuse.js\";\nimport {\n  css,\n  CSSResult,\n  customElement,\n  html,\n  LitElement,\n  property,\n  PropertyValues,\n  TemplateResult,\n} from \"lit-element\";\nimport { classMap } from \"lit-html/directives/class-map\";\nimport { until } from \"lit-html/directives/until\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../../../common/dom/fire_event\";\nimport \"../../../../common/search/search-input\";\nimport { UNAVAILABLE_STATES } from \"../../../../data/entity\";\nimport { LovelaceCardConfig, LovelaceConfig } from \"../../../../data/lovelace\";\nimport {\n  CustomCardEntry,\n  customCards,\n  CUSTOM_TYPE_PREFIX,\n  getCustomCardEntry,\n} from \"../../../../data/lovelace_custom_cards\";\nimport { HomeAssistant } from \"../../../../types\";\nimport {\n  calcUnusedEntities,\n  computeUsedEntities,\n} from \"../../common/compute-unused-entities\";\nimport { createCardElement } from \"../../create-element/create-card-element\";\nimport { LovelaceCard } from \"../../types\";\nimport { getCardStubConfig } from \"../get-card-stub-config\";\nimport { CardPickTarget, Card } from \"../types\";\nimport { coreCards } from \"../lovelace-cards\";\n\ninterface CardElement {\n  card: Card;\n  element: TemplateResult;\n}\n\n@customElement(\"hui-card-picker\")\nexport class HuiCardPicker extends LitElement {\n  @property() public hass?: HomeAssistant;\n\n  @property() private _cards: CardElement[] = [];\n\n  public lovelace?: LovelaceConfig;\n\n  public cardPicked?: (cardConf: LovelaceCardConfig) => void;\n\n  private _filter?: string;\n\n  private _unusedEntities?: string[];\n\n  private _usedEntities?: string[];\n\n  private _filterCards = memoizeOne(\n    (cardElements: CardElement[], filter?: string): CardElement[] => {\n      if (filter) {\n        let cards = cardElements.map(\n          (cardElement: CardElement) => cardElement.card\n        );\n        const options: Fuse.IFuseOptions<Card> = {\n          keys: [\"type\", \"name\", \"description\"],\n          isCaseSensitive: false,\n          minMatchCharLength: 2,\n          threshold: 0.2,\n        };\n        const fuse = new Fuse(cards, options);\n        cards = fuse.search(filter).map((result) => result.item);\n        cardElements = cardElements.filter((cardElement: CardElement) =>\n          cards.includes(cardElement.card)\n        );\n      }\n      return cardElements;\n    }\n  );\n\n  protected render(): TemplateResult {\n    if (\n      !this.hass ||\n      !this.lovelace ||\n      !this._unusedEntities ||\n      !this._usedEntities\n    ) {\n      return html``;\n    }\n\n    return html`\n      <search-input\n        .filter=${this._filter}\n        no-label-float\n        @value-changed=${this._handleSearchChange}\n      ></search-input>\n      <div class=\"cards-container\">\n        ${this._filterCards(this._cards, this._filter).map(\n          (cardElement: CardElement) => cardElement.element\n        )}\n      </div>\n      <div class=\"cards-container\">\n        <div\n          class=\"card manual\"\n          @click=${this._cardPicked}\n          .config=${{ type: \"\" }}\n        >\n          <div class=\"preview description\">\n            ${this.hass!.localize(\n              `ui.panel.lovelace.editor.card.generic.manual_description`\n            )}\n          </div>\n          <div class=\"card-header\">\n            ${this.hass!.localize(\n              `ui.panel.lovelace.editor.card.generic.manual`\n            )}\n          </div>\n        </div>\n      </div>\n    `;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    if (!oldHass) {\n      return true;\n    }\n\n    if (oldHass.language !== this.hass!.language) {\n      return true;\n    }\n\n    return false;\n  }\n\n  protected firstUpdated(): void {\n    if (!this.hass || !this.lovelace) {\n      return;\n    }\n\n    const usedEntities = computeUsedEntities(this.lovelace);\n    const unusedEntities = calcUnusedEntities(this.hass, usedEntities);\n\n    this._usedEntities = [...usedEntities].filter(\n      (eid) =>\n        this.hass!.states[eid] &&\n        !UNAVAILABLE_STATES.includes(this.hass!.states[eid].state)\n    );\n    this._unusedEntities = [...unusedEntities].filter(\n      (eid) =>\n        this.hass!.states[eid] &&\n        !UNAVAILABLE_STATES.includes(this.hass!.states[eid].state)\n    );\n\n    this._loadCards();\n  }\n\n  private _loadCards() {\n    let cards: Card[] = coreCards.map((card: Card) => ({\n      name: this.hass!.localize(\n        `ui.panel.lovelace.editor.card.${card.type}.name`\n      ),\n      description: this.hass!.localize(\n        `ui.panel.lovelace.editor.card.${card.type}.description`\n      ),\n      ...card,\n    }));\n    if (customCards.length > 0) {\n      cards = cards.concat(\n        customCards.map((ccard: CustomCardEntry) => ({\n          type: ccard.type,\n          name: ccard.name,\n          description: ccard.description,\n          showElement: ccard.preview,\n          isCustom: true,\n        }))\n      );\n    }\n    this._cards = cards.map((card: Card) => ({\n      card: card,\n      element: html`${until(\n        this._renderCardElement(card),\n        html`\n          <div class=\"card spinner\">\n            <paper-spinner active alt=\"Loading\"></paper-spinner>\n          </div>\n        `\n      )}`,\n    }));\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    this._filter = ev.detail.value;\n    this.requestUpdate();\n  }\n\n  static get styles(): CSSResult[] {\n    return [\n      css`\n        .cards-container {\n          display: grid;\n          grid-gap: 8px 8px;\n          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n          margin-top: 20px;\n        }\n\n        .card {\n          height: 100%;\n          max-width: 500px;\n          display: flex;\n          flex-direction: column;\n          border-radius: 4px;\n          border: 1px solid var(--divider-color);\n          background: var(--primary-background-color, #fafafa);\n          cursor: pointer;\n          box-sizing: border-box;\n          position: relative;\n        }\n\n        .card-header {\n          color: var(--ha-card-header-color, --primary-text-color);\n          font-family: var(--ha-card-header-font-family, inherit);\n          font-size: 16px;\n          letter-spacing: -0.012em;\n          line-height: 20px;\n          padding: 12px 16px;\n          display: block;\n          text-align: center;\n          background: var(\n            --ha-card-background,\n            var(--paper-card-background-color, white)\n          );\n          border-radius: 0 0 4px 4px;\n          border-top: 1px solid var(--divider-color);\n        }\n\n        .preview {\n          pointer-events: none;\n          margin: 20px;\n          flex-grow: 1;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n        }\n\n        .preview > :first-child {\n          zoom: 0.6;\n          display: block;\n          width: 100%;\n        }\n\n        .description {\n          text-align: center;\n        }\n\n        .spinner {\n          align-items: center;\n          justify-content: center;\n        }\n\n        .overlay {\n          position: absolute;\n          width: 100%;\n          height: 100%;\n          z-index: 1;\n        }\n\n        .manual {\n          max-width: none;\n        }\n      `,\n    ];\n  }\n\n  private _cardPicked(ev: Event): void {\n    const config: LovelaceCardConfig = (ev.currentTarget! as CardPickTarget)\n      .config;\n\n    fireEvent(this, \"config-changed\", { config });\n  }\n\n  private _createCardElement(cardConfig: LovelaceCardConfig) {\n    const element = createCardElement(cardConfig) as LovelaceCard;\n    element.hass = this.hass;\n    element.addEventListener(\n      \"ll-rebuild\",\n      (ev) => {\n        ev.stopPropagation();\n        this._rebuildCard(element, cardConfig);\n      },\n      { once: true }\n    );\n    return element;\n  }\n\n  private _rebuildCard(\n    cardElToReplace: LovelaceCard,\n    config: LovelaceCardConfig\n  ): void {\n    const newCardEl = this._createCardElement(config);\n    if (cardElToReplace.parentElement) {\n      cardElToReplace.parentElement!.replaceChild(newCardEl, cardElToReplace);\n    }\n  }\n\n  private async _renderCardElement(card: Card): Promise<TemplateResult> {\n    let { type } = card;\n    const { showElement, isCustom, name, description } = card;\n    const customCard = isCustom ? getCustomCardEntry(type) : undefined;\n    if (isCustom) {\n      type = `${CUSTOM_TYPE_PREFIX}${type}`;\n    }\n\n    let element: LovelaceCard | undefined;\n    let cardConfig: LovelaceCardConfig = { type };\n\n    if (this.hass && this.lovelace) {\n      cardConfig = await getCardStubConfig(\n        this.hass,\n        type,\n        this._unusedEntities!,\n        this._usedEntities!\n      );\n\n      if (showElement) {\n        element = this._createCardElement(cardConfig);\n      }\n    }\n\n    return html`\n      <div class=\"card\">\n        <div\n          class=\"overlay\"\n          @click=${this._cardPicked}\n          .config=${cardConfig}\n        ></div>\n        <div\n          class=\"preview ${classMap({\n            description: !element || element.tagName === \"HUI-ERROR-CARD\",\n          })}\"\n        >\n          ${element && element.tagName !== \"HUI-ERROR-CARD\"\n            ? element\n            : customCard\n            ? customCard.description ||\n              this.hass!.localize(\n                `ui.panel.lovelace.editor.cardpicker.no_description`\n              )\n            : description}\n        </div>\n        <div class=\"card-header\">\n          ${customCard\n            ? `${this.hass!.localize(\n                \"ui.panel.lovelace.editor.cardpicker.custom_card\"\n              )}: ${customCard.name || customCard.type}`\n            : name}\n        </div>\n      </div>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-card-picker\": HuiCardPicker;\n  }\n}\n","import \"@material/mwc-button\";\nimport { safeDump, safeLoad } from \"js-yaml\";\nimport {\n  css,\n  CSSResult,\n  customElement,\n  html,\n  LitElement,\n  property,\n  TemplateResult,\n} from \"lit-element\";\nimport { fireEvent } from \"../../../../common/dom/fire_event\";\nimport { computeRTL } from \"../../../../common/util/compute_rtl\";\nimport \"../../../../components/ha-code-editor\";\nimport type { HaCodeEditor } from \"../../../../components/ha-code-editor\";\nimport type {\n  LovelaceCardConfig,\n  LovelaceConfig,\n} from \"../../../../data/lovelace\";\nimport type { HomeAssistant } from \"../../../../types\";\nimport { getCardElementClass } from \"../../create-element/create-card-element\";\nimport type { EntityConfig } from \"../../entity-rows/types\";\nimport type { LovelaceCardEditor } from \"../../types\";\nimport type { GUIModeChangedEvent } from \"../types\";\n\nexport interface ConfigChangedEvent {\n  config: LovelaceCardConfig;\n  error?: string;\n  guiModeAvailable?: boolean;\n}\n\ndeclare global {\n  interface HASSDomEvents {\n    \"entities-changed\": {\n      entities: EntityConfig[];\n    };\n    \"config-changed\": ConfigChangedEvent;\n    \"GUImode-changed\": GUIModeChangedEvent;\n  }\n}\n\nexport interface UIConfigChangedEvent extends Event {\n  detail: {\n    config: LovelaceCardConfig;\n  };\n}\n\n@customElement(\"hui-card-editor\")\nexport class HuiCardEditor extends LitElement {\n  @property() public hass!: HomeAssistant;\n\n  @property() public lovelace?: LovelaceConfig;\n\n  @property() private _yaml?: string;\n\n  @property() private _config?: LovelaceCardConfig;\n\n  @property() private _configElement?: LovelaceCardEditor;\n\n  @property() private _configElType?: string;\n\n  @property() private _GUImode = true;\n\n  // Error: Configuration broken - do not save\n  @property() private _error?: string;\n\n  // Warning: GUI editor can't handle configuration - ok to save\n  @property() private _warning?: string;\n\n  @property() private _loading = false;\n\n  public get yaml(): string {\n    return this._yaml || \"\";\n  }\n\n  public set yaml(_yaml: string) {\n    this._yaml = _yaml;\n    try {\n      this._config = safeLoad(this.yaml);\n      this._updateConfigElement();\n      this._error = undefined;\n    } catch (err) {\n      this._error = err.message;\n    }\n    fireEvent(this, \"config-changed\", {\n      config: this.value!,\n      error: this._error,\n      guiModeAvailable: !(this.hasWarning || this.hasError),\n    });\n  }\n\n  public get value(): LovelaceCardConfig | undefined {\n    return this._config;\n  }\n\n  public set value(config: LovelaceCardConfig | undefined) {\n    if (JSON.stringify(config) !== JSON.stringify(this._config || {})) {\n      this.yaml = safeDump(config);\n    }\n  }\n\n  public get hasWarning(): boolean {\n    return this._warning !== undefined;\n  }\n\n  public get hasError(): boolean {\n    return this._error !== undefined;\n  }\n\n  public get GUImode(): boolean {\n    return this._GUImode;\n  }\n\n  public set GUImode(guiMode: boolean) {\n    this._GUImode = guiMode;\n    fireEvent(this as HTMLElement, \"GUImode-changed\", {\n      guiMode,\n      guiModeAvailable: !(this.hasWarning || this.hasError),\n    });\n  }\n\n  private get _yamlEditor(): HaCodeEditor {\n    return this.shadowRoot!.querySelector(\"ha-code-editor\")! as HaCodeEditor;\n  }\n\n  public toggleMode() {\n    this.GUImode = !this.GUImode;\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._refreshYamlEditor();\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"wrapper\">\n        ${this.GUImode\n          ? html`\n              <div class=\"gui-editor\">\n                ${this._loading\n                  ? html`\n                      <paper-spinner\n                        active\n                        alt=\"Loading\"\n                        class=\"center margin-bot\"\n                      ></paper-spinner>\n                    `\n                  : this._configElement}\n              </div>\n            `\n          : html`\n              <div class=\"yaml-editor\">\n                <ha-code-editor\n                  mode=\"yaml\"\n                  autofocus\n                  .value=${this.yaml}\n                  .error=${this._error}\n                  .rtl=${computeRTL(this.hass)}\n                  @value-changed=${this._handleYAMLChanged}\n                ></ha-code-editor>\n              </div>\n            `}\n        ${this._error\n          ? html`\n              <div class=\"error\">\n                ${this._error}\n              </div>\n            `\n          : \"\"}\n        ${this._warning\n          ? html`\n              <div class=\"warning\">\n                ${this._warning}\n              </div>\n            `\n          : \"\"}\n      </div>\n    `;\n  }\n\n  protected updated(changedProperties) {\n    super.updated(changedProperties);\n\n    if (changedProperties.has(\"_GUImode\")) {\n      if (this.GUImode === false) {\n        // Refresh code editor when switching to yaml mode\n        this._refreshYamlEditor(true);\n      }\n      fireEvent(this as HTMLElement, \"iron-resize\");\n    }\n\n    if (this._configElement && changedProperties.has(\"hass\")) {\n      this._configElement.hass = this.hass;\n    }\n    if (this._configElement && changedProperties.has(\"lovelace\")) {\n      this._configElement.lovelace = this.lovelace;\n    }\n  }\n\n  private _refreshYamlEditor(focus = false) {\n    // wait on render\n    setTimeout(() => {\n      if (this._yamlEditor && this._yamlEditor.codemirror) {\n        this._yamlEditor.codemirror.refresh();\n        if (focus) {\n          this._yamlEditor.codemirror.focus();\n        }\n      }\n      fireEvent(this as HTMLElement, \"iron-resize\");\n    }, 1);\n  }\n\n  private _handleUIConfigChanged(ev: UIConfigChangedEvent) {\n    ev.stopPropagation();\n    const config = ev.detail.config;\n    this.value = config;\n  }\n\n  private _handleYAMLChanged(ev) {\n    ev.stopPropagation();\n    const newYaml = ev.detail.value;\n    if (newYaml !== this.yaml) {\n      this.yaml = newYaml;\n    }\n  }\n\n  private async _updateConfigElement(): Promise<void> {\n    if (!this.value) {\n      return;\n    }\n\n    const cardType = this.value.type;\n    let configElement = this._configElement;\n    try {\n      this._error = undefined;\n      this._warning = undefined;\n\n      if (this._configElType !== cardType) {\n        // If the card type has changed, we need to load a new GUI editor\n        if (!this.value.type) {\n          throw new Error(\"No card type defined\");\n        }\n\n        const elClass = await getCardElementClass(cardType);\n\n        this._loading = true;\n        // Check if a GUI editor exists\n        if (elClass && elClass.getConfigElement) {\n          configElement = await elClass.getConfigElement();\n        } else {\n          configElement = undefined;\n          throw Error(`WARNING: No visual editor available for: ${cardType}`);\n        }\n\n        this._configElement = configElement;\n        this._configElType = cardType;\n\n        // Perform final setup\n        this._configElement.hass = this.hass;\n        this._configElement.lovelace = this.lovelace;\n        this._configElement.addEventListener(\"config-changed\", (ev) =>\n          this._handleUIConfigChanged(ev as UIConfigChangedEvent)\n        );\n      }\n\n      // Setup GUI editor and check that it can handle the current config\n      try {\n        this._configElement!.setConfig(this.value);\n      } catch (err) {\n        throw Error(`WARNING: ${err.message}`);\n      }\n    } catch (err) {\n      if (err.message.startsWith(\"WARNING:\")) {\n        this._warning = err.message.substr(8);\n      } else {\n        this._error = err;\n      }\n      this.GUImode = false;\n    } finally {\n      this._loading = false;\n      fireEvent(this, \"iron-resize\");\n    }\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: flex;\n      }\n      .wrapper {\n        width: 100%;\n      }\n      .gui-editor,\n      .yaml-editor {\n        padding: 8px 0px;\n      }\n      .error {\n        color: #ef5350;\n      }\n      .warning {\n        color: #ffa726;\n      }\n      paper-spinner {\n        display: block;\n        margin: auto;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-card-editor\": HuiCardEditor;\n  }\n}\n","import \"@polymer/paper-dialog-scrollable/paper-dialog-scrollable\";\nimport deepFreeze from \"deep-freeze\";\nimport {\n  css,\n  CSSResultArray,\n  customElement,\n  html,\n  LitElement,\n  property,\n  query,\n  TemplateResult,\n  PropertyValues,\n} from \"lit-element\";\nimport type { HASSDomEvent } from \"../../../../common/dom/fire_event\";\nimport \"../../../../components/dialog/ha-paper-dialog\";\nimport type {\n  LovelaceCardConfig,\n  LovelaceViewConfig,\n} from \"../../../../data/lovelace\";\nimport { haStyleDialog } from \"../../../../resources/styles\";\nimport type { HomeAssistant } from \"../../../../types\";\nimport { showSaveSuccessToast } from \"../../../../util/toast-saved-success\";\nimport { addCard, replaceCard } from \"../config-util\";\nimport type { GUIModeChangedEvent } from \"../types\";\nimport \"./hui-card-editor\";\nimport type { ConfigChangedEvent, HuiCardEditor } from \"./hui-card-editor\";\nimport \"./hui-card-picker\";\nimport \"./hui-card-preview\";\nimport type { EditCardDialogParams } from \"./show-edit-card-dialog\";\nimport { getCardDocumentationURL } from \"../get-card-documentation-url\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"reload-lovelace\": undefined;\n  }\n  // for add event listener\n  interface HTMLElementEventMap {\n    \"reload-lovelace\": HASSDomEvent<undefined>;\n  }\n}\n\n@customElement(\"hui-dialog-edit-card\")\nexport class HuiDialogEditCard extends LitElement {\n  @property() protected hass!: HomeAssistant;\n\n  @property() private _params?: EditCardDialogParams;\n\n  @property() private _cardConfig?: LovelaceCardConfig;\n\n  @property() private _viewConfig!: LovelaceViewConfig;\n\n  @property() private _saving = false;\n\n  @property() private _error?: string;\n\n  @property() private _guiModeAvailable? = true;\n\n  @query(\"hui-card-editor\") private _cardEditorEl?: HuiCardEditor;\n\n  @property() private _GUImode = true;\n\n  @property() private _documentationURL?: string;\n\n  public async showDialog(params: EditCardDialogParams): Promise<void> {\n    this._params = params;\n    this._GUImode = true;\n    this._guiModeAvailable = true;\n    const [view, card] = params.path;\n    this._viewConfig = params.lovelaceConfig.views[view];\n    this._cardConfig =\n      card !== undefined ? this._viewConfig.cards![card] : params.cardConfig;\n    if (this._cardConfig && !Object.isFrozen(this._cardConfig)) {\n      this._cardConfig = deepFreeze(this._cardConfig);\n    }\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (\n      !this._cardConfig ||\n      this._documentationURL !== undefined ||\n      !changedProps.has(\"_cardConfig\")\n    ) {\n      return;\n    }\n\n    const oldConfig = changedProps.get(\"_cardConfig\") as LovelaceCardConfig;\n\n    if (oldConfig?.type !== this._cardConfig!.type) {\n      this._documentationURL = getCardDocumentationURL(this._cardConfig!.type);\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this._params) {\n      return html``;\n    }\n\n    let heading: string;\n    if (this._cardConfig && this._cardConfig.type) {\n      heading = `${this.hass!.localize(\n        `ui.panel.lovelace.editor.card.${this._cardConfig.type}.name`\n      )} ${this.hass!.localize(\"ui.panel.lovelace.editor.edit_card.header\")}`;\n    } else if (!this._cardConfig) {\n      heading = this._viewConfig.title\n        ? this.hass!.localize(\n            \"ui.panel.lovelace.editor.edit_card.pick_card_view_title\",\n            \"name\",\n            `\"${this._viewConfig.title}\"`\n          )\n        : this.hass!.localize(\"ui.panel.lovelace.editor.edit_card.pick_card\");\n    } else {\n      heading = this.hass!.localize(\n        \"ui.panel.lovelace.editor.edit_card.header\"\n      );\n    }\n\n    return html`\n      <ha-paper-dialog with-backdrop opened modal @keyup=${this._handleKeyUp}>\n        <div class=\"header\">\n          <h2>\n            ${heading}\n          </h2>\n          ${this._documentationURL !== undefined\n            ? html`\n                <a\n                  class=\"help-icon\"\n                  href=${this._documentationURL}\n                  target=\"_blank\"\n                  rel=\"noreferrer\"\n                >\n                  <ha-icon-button\n                    icon=\"hass:help-circle\"\n                    .title=${this.hass!.localize(\"ui.panel.lovelace.menu.help\")}\n                  ></ha-icon-button>\n                </a>\n              `\n            : \"\"}\n        </div>\n        <paper-dialog-scrollable>\n          ${this._cardConfig === undefined\n            ? html`\n                <hui-card-picker\n                  .lovelace=${this._params.lovelaceConfig}\n                  .hass=${this.hass}\n                  @config-changed=${this._handleCardPicked}\n                ></hui-card-picker>\n              `\n            : html`\n                <div class=\"content\">\n                  <div class=\"element-editor\">\n                    <hui-card-editor\n                      .hass=${this.hass}\n                      .lovelace=${this._params.lovelaceConfig}\n                      .value=${this._cardConfig}\n                      @config-changed=${this._handleConfigChanged}\n                      @GUImode-changed=${this._handleGUIModeChanged}\n                    ></hui-card-editor>\n                  </div>\n                  <div class=\"element-preview\">\n                    <hui-card-preview\n                      .hass=${this.hass}\n                      .config=${this._cardConfig}\n                      class=${this._error ? \"blur\" : \"\"}\n                    ></hui-card-preview>\n                    ${this._error\n                      ? html`\n                          <paper-spinner\n                            active\n                            alt=\"Can't update card\"\n                          ></paper-spinner>\n                        `\n                      : ``}\n                  </div>\n                </div>\n              `}\n        </paper-dialog-scrollable>\n        <div class=\"paper-dialog-buttons\">\n          ${this._cardConfig !== undefined\n            ? html`\n                <mwc-button\n                  @click=${this._toggleMode}\n                  .disabled=${!this._guiModeAvailable}\n                  class=\"gui-mode-button\"\n                >\n                  ${this.hass!.localize(\n                    !this._cardEditorEl || this._GUImode\n                      ? \"ui.panel.lovelace.editor.edit_card.show_code_editor\"\n                      : \"ui.panel.lovelace.editor.edit_card.show_visual_editor\"\n                  )}\n                </mwc-button>\n              `\n            : \"\"}\n          <mwc-button @click=${this._close}>\n            ${this.hass!.localize(\"ui.common.cancel\")}\n          </mwc-button>\n          ${this._cardConfig !== undefined\n            ? html`\n                <mwc-button\n                  ?disabled=${!this._canSave || this._saving}\n                  @click=${this._save}\n                >\n                  ${this._saving\n                    ? html`\n                        <paper-spinner active alt=\"Saving\"></paper-spinner>\n                      `\n                    : this.hass!.localize(\"ui.common.save\")}\n                </mwc-button>\n              `\n            : ``}\n        </div>\n      </ha-paper-dialog>\n    `;\n  }\n\n  static get styles(): CSSResultArray {\n    return [\n      haStyleDialog,\n      css`\n        :host {\n          --code-mirror-max-height: calc(100vh - 176px);\n        }\n\n        @media all and (max-width: 450px), all and (max-height: 500px) {\n          /* overrule the ha-style-dialog max-height on small screens */\n          ha-paper-dialog {\n            max-height: 100%;\n            height: 100%;\n          }\n        }\n\n        @media all and (min-width: 850px) {\n          ha-paper-dialog {\n            width: 845px;\n          }\n        }\n\n        ha-paper-dialog {\n          max-width: 845px;\n        }\n\n        .center {\n          margin-left: auto;\n          margin-right: auto;\n        }\n\n        .content {\n          display: flex;\n          flex-direction: column;\n          margin: 0 -10px;\n        }\n        .content hui-card-preview {\n          margin: 4px auto;\n          max-width: 390px;\n        }\n        .content .element-editor {\n          margin: 0 10px;\n        }\n\n        @media (min-width: 1200px) {\n          ha-paper-dialog {\n            max-width: none;\n            width: 1000px;\n          }\n\n          .content {\n            flex-direction: row;\n          }\n          .content > * {\n            flex-basis: 0;\n            flex-grow: 1;\n            flex-shrink: 1;\n            min-width: 0;\n          }\n          .content hui-card-preview {\n            padding: 8px 10px;\n            margin: auto 0px;\n            max-width: 500px;\n          }\n        }\n\n        mwc-button paper-spinner {\n          width: 14px;\n          height: 14px;\n          margin-right: 20px;\n        }\n        .hidden {\n          display: none;\n        }\n        .element-editor {\n          margin-bottom: 8px;\n        }\n        .blur {\n          filter: blur(2px) grayscale(100%);\n        }\n        .element-preview {\n          position: relative;\n        }\n        .element-preview paper-spinner {\n          top: 50%;\n          left: 50%;\n          position: absolute;\n          z-index: 10;\n        }\n        hui-card-preview {\n          padding-top: 8px;\n          margin-bottom: 4px;\n          display: block;\n          width: 100%;\n          box-sizing: border-box;\n        }\n        .gui-mode-button {\n          margin-right: auto;\n        }\n        .header {\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n        }\n        .help-icon {\n          text-decoration: none;\n          color: inherit;\n        }\n      `,\n    ];\n  }\n\n  private _handleCardPicked(ev) {\n    const config = ev.detail.config;\n    if (this._params!.entities && this._params!.entities.length) {\n      if (Object.keys(config).includes(\"entities\")) {\n        config.entities = this._params!.entities;\n      } else if (Object.keys(config).includes(\"entity\")) {\n        config.entity = this._params!.entities[0];\n      }\n    }\n    this._cardConfig = deepFreeze(config);\n    this._error = ev.detail.error;\n  }\n\n  private _handleConfigChanged(ev: HASSDomEvent<ConfigChangedEvent>) {\n    this._cardConfig = deepFreeze(ev.detail.config);\n    this._error = ev.detail.error;\n    this._guiModeAvailable = ev.detail.guiModeAvailable;\n  }\n\n  private _handleKeyUp(ev: KeyboardEvent) {\n    if (ev.keyCode === 27) {\n      this._close();\n    }\n  }\n\n  private _handleGUIModeChanged(ev: HASSDomEvent<GUIModeChangedEvent>): void {\n    ev.stopPropagation();\n    this._GUImode = ev.detail.guiMode;\n    this._guiModeAvailable = ev.detail.guiModeAvailable;\n  }\n\n  private _toggleMode(): void {\n    this._cardEditorEl?.toggleMode();\n  }\n\n  private _close(): void {\n    this._params = undefined;\n    this._cardConfig = undefined;\n    this._error = undefined;\n    this._documentationURL = undefined;\n  }\n\n  private get _canSave(): boolean {\n    if (this._saving) {\n      return false;\n    }\n    if (this._cardConfig === undefined) {\n      return false;\n    }\n    if (this._cardEditorEl && this._cardEditorEl.hasError) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _save(): Promise<void> {\n    this._saving = true;\n    await this._params!.saveConfig(\n      this._params!.path.length === 1\n        ? addCard(\n            this._params!.lovelaceConfig,\n            this._params!.path as [number],\n            this._cardConfig!\n          )\n        : replaceCard(\n            this._params!.lovelaceConfig,\n            this._params!.path as [number, number],\n            this._cardConfig!\n          )\n    );\n    this._saving = false;\n    showSaveSuccessToast(this, this.hass);\n    this._close();\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-dialog-edit-card\": HuiDialogEditCard;\n  }\n}\n"],"mappings":";AAgBA;;;;;;;;;;AC2BA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;AAIA;;;;AAKA;;;;AAIA;;;;AAOA;;;;;;;;;;;AAvDA;;AC0EA;;AAEA;;;AAGA;;;;;AAOA;AACA;;;AAGA;;;AAKA;;;;AA1BA;;;;AA5CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAkSA;AACA;;;AAGA;;AAIA;;;AAUA;;;AApTA;;ACgGA;;AAGA;;;;;;AAQA;;AAGA;;;;;AAKA;AACA;AACA;AACA;;;;AAIA;;AAGA;;AAGA;AACA;;AAGA;;AAGA;;AAhIA;;;;;;;;;;;;;;;;;;;;;AAAA;ACsEA;;;AAGA;;AAEA;;;AAIA;;;;;;AAMA;;;AAIA;;;AAGA;;AAGA;AACA;AACA;;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;;;;AAOA;;;;;;AAMA;;AAGA;AACA;;;AAGA;;AAOA;AACA;AACA;;AAEA;;AAGA;AACA;;AAEA;;AAIA;;AAGA;;;AAtKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sourceRoot":""}