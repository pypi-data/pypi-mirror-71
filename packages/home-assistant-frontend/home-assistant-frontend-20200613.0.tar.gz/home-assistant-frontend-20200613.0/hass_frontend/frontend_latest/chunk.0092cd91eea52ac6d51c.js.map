{"version":3,"file":"chunk.0092cd91eea52ac6d51c.js","sources":["webpack:///./src/components/dialog/ha-iron-focusables-helper.js","webpack:///./src/components/ha-formfield.ts","webpack:///./src/panels/lovelace/editor/hui-dialog-save-config.ts"],"sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n/*\n  Fixes issue with not using shadow dom properly in iron-overlay-behavior/icon-focusables-helper.js\n*/\nimport { IronFocusablesHelper } from \"@polymer/iron-overlay-behavior/iron-focusables-helper\";\nimport { dom } from \"@polymer/polymer/lib/legacy/polymer.dom\";\n\nexport const HaIronFocusablesHelper = {\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the chidren,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  getTabbableNodes: function (node) {\n    var result = [];\n    // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n    var needsSortByTabIndex = this._collectTabbableNodes(node, result);\n    if (needsSortByTabIndex) {\n      return IronFocusablesHelper._sortByTabIndex(result);\n    }\n    return result;\n  },\n\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result`\n   * if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n  _collectTabbableNodes: function (node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (\n      node.nodeType !== Node.ELEMENT_NODE ||\n      !IronFocusablesHelper._isVisible(node)\n    ) {\n      return false;\n    }\n    var element = /** @type {!HTMLElement} */ (node);\n    var tabIndex = IronFocusablesHelper._normalizedTabIndex(element);\n    var needsSort = tabIndex > 0;\n    if (tabIndex >= 0) {\n      result.push(element);\n    }\n\n    // In ShadowDOM v1, tab order is affected by the order of distrubution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distrubution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.\n    var children;\n    if (element.localName === \"content\" || element.localName === \"slot\") {\n      children = dom(element).getDistributedNodes();\n    } else {\n      // /////////////////////////\n      // Use shadow root if possible, will check for distributed nodes.\n      // THIS IS THE CHANGED LINE\n      children = dom(element.shadowRoot || element.root || element).children;\n      // /////////////////////////\n    }\n    for (var i = 0; i < children.length; i++) {\n      // Ensure method is always invoked to collect tabbable children.\n      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n    }\n    return needsSort;\n  },\n};\n","import \"@material/mwc-formfield\";\nimport type { Formfield } from \"@material/mwc-formfield\";\nimport { style } from \"@material/mwc-formfield/mwc-formfield-css\";\nimport { css, CSSResult, customElement } from \"lit-element\";\nimport { Constructor } from \"../types\";\n\nconst MwcFormfield = customElements.get(\"mwc-formfield\") as Constructor<\n  Formfield\n>;\n\n@customElement(\"ha-formfield\")\nexport class HaFormfield extends MwcFormfield {\n  protected static get styles(): CSSResult[] {\n    return [\n      style,\n      css`\n        ::slotted(ha-switch) {\n          margin-right: 10px;\n        }\n        [dir=\"rtl\"] ::slotted(ha-switch),\n        ::slotted(ha-switch)[dir=\"rtl\"] {\n          margin-left: 10px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-formfield\": HaFormfield;\n  }\n}\n","import \"@material/mwc-button\";\nimport \"@polymer/paper-dialog-scrollable/paper-dialog-scrollable\";\nimport \"@polymer/paper-spinner/paper-spinner\";\nimport {\n  css,\n  CSSResult,\n  customElement,\n  html,\n  LitElement,\n  property,\n  query,\n  TemplateResult,\n} from \"lit-element\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport \"../../../components/dialog/ha-paper-dialog\";\nimport type { HaPaperDialog } from \"../../../components/dialog/ha-paper-dialog\";\nimport \"../../../components/ha-switch\";\nimport \"../../../components/ha-formfield\";\nimport \"../../../components/ha-yaml-editor\";\nimport type { PolymerChangedEvent } from \"../../../polymer-types\";\nimport { haStyleDialog } from \"../../../resources/styles\";\nimport type { HomeAssistant } from \"../../../types\";\nimport type { SaveDialogParams } from \"./show-save-config-dialog\";\n\nconst EMPTY_CONFIG = { views: [] };\n\n@customElement(\"hui-dialog-save-config\")\nexport class HuiSaveConfig extends LitElement {\n  @property() public hass?: HomeAssistant;\n\n  @property() private _params?: SaveDialogParams;\n\n  @property() private _emptyConfig = false;\n\n  @property() private _saving: boolean;\n\n  @query(\"ha-paper-dialog\") private _dialog?: HaPaperDialog;\n\n  public constructor() {\n    super();\n    this._saving = false;\n  }\n\n  public async showDialog(params: SaveDialogParams): Promise<void> {\n    this._params = params;\n    this._emptyConfig = false;\n    await this.updateComplete;\n    this._dialog!.open();\n  }\n\n  protected render(): TemplateResult {\n    if (!this._params) {\n      return html``;\n    }\n    return html`\n      <ha-paper-dialog\n        with-backdrop\n        opened\n        @opened-changed=${this._openedChanged}\n      >\n        <h2>\n          ${this.hass!.localize(\"ui.panel.lovelace.editor.save_config.header\")}\n        </h2>\n        <paper-dialog-scrollable>\n          <p>\n            ${this.hass!.localize(\"ui.panel.lovelace.editor.save_config.para\")}\n          </p>\n\n          ${this._params.mode === \"storage\"\n            ? html`\n                <p>\n                  ${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.para_sure\"\n                  )}\n                </p>\n                <ha-formfield\n                  .label=${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.empty_config\"\n                  )}\n                >\n                  <ha-switch\n                    .checked=${this._emptyConfig}\n                    @change=${this._emptyConfigChanged}\n                  ></ha-switch\n                ></ha-formfield>\n              `\n            : html`\n                <p>\n                  ${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.yaml_mode\"\n                  )}\n                </p>\n                <p>\n                  ${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.yaml_control\"\n                  )}\n                </p>\n                <p>\n                  ${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.yaml_config\"\n                  )}\n                </p>\n                <ha-yaml-editor\n                  .defaultValue=${this._params!.lovelace.config}\n                  @editor-refreshed=${this._editorRefreshed}\n                ></ha-yaml-editor>\n              `}\n        </paper-dialog-scrollable>\n        <div class=\"paper-dialog-buttons\">\n          ${this._params.mode === \"storage\"\n            ? html`\n                <mwc-button @click=\"${this._closeDialog}\"\n                  >${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.cancel\"\n                  )}\n                </mwc-button>\n                <mwc-button\n                  ?disabled=\"${this._saving}\"\n                  @click=\"${this._saveConfig}\"\n                >\n                  <paper-spinner\n                    ?active=\"${this._saving}\"\n                    alt=\"Saving\"\n                  ></paper-spinner>\n                  ${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.save\"\n                  )}\n                </mwc-button>\n              `\n            : html`\n                <mwc-button @click=${this._closeDialog}\n                  >${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.save_config.close\"\n                  )}\n                </mwc-button>\n              `}\n        </div>\n      </ha-paper-dialog>\n    `;\n  }\n\n  private _closeDialog(): void {\n    this._dialog!.close();\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>): void {\n    if (!ev.detail.value) {\n      this._params = undefined;\n    }\n  }\n\n  private _editorRefreshed() {\n    fireEvent(this._dialog! as HTMLElement, \"iron-resize\");\n  }\n\n  private _emptyConfigChanged(ev) {\n    this._emptyConfig = ev.target.checked;\n  }\n\n  private async _saveConfig(): Promise<void> {\n    if (!this.hass || !this._params) {\n      return;\n    }\n    this._saving = true;\n    try {\n      const lovelace = this._params!.lovelace;\n      await lovelace.saveConfig(\n        this._emptyConfig ? EMPTY_CONFIG : lovelace.config\n      );\n      lovelace.setEditMode(true);\n      this._saving = false;\n      this._closeDialog();\n    } catch (err) {\n      alert(`Saving failed: ${err.message}`);\n      this._saving = false;\n    }\n  }\n\n  static get styles(): CSSResult[] {\n    return [\n      haStyleDialog,\n      css`\n        @media all and (max-width: 450px), all and (max-height: 500px) {\n          /* overrule the ha-style-dialog max-height on small screens */\n          ha-paper-dialog {\n            max-height: 100%;\n            height: 100%;\n          }\n        }\n        @media all and (min-width: 660px) {\n          ha-paper-dialog {\n            width: 650px;\n          }\n        }\n        ha-paper-dialog {\n          max-width: 650px;\n        }\n        paper-spinner {\n          display: none;\n        }\n        paper-spinner[active] {\n          display: block;\n        }\n        mwc-button paper-spinner {\n          width: 14px;\n          height: 14px;\n          margin-right: 20px;\n        }\n        ha-switch {\n          padding-bottom: 16px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-dialog-save-config\": HuiSaveConfig;\n  }\n}\n"],"mappings":";AAgBA;;;;;;;;ACLA;;;;AC+CA;;;AAGA;;;;AAIA;;;AAGA;;AAGA;;;AAKA;;;AAKA;AACA;;;AAIA;;AAEA;;;AAKA;;;AAKA;;;AAKA;AACA;;;;;AAKA;AAEA;AACA;;;AAKA;AACA;;;AAGA;;;AAGA;;AAKA;AACA;AACA;;;;;AA/EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzBA","sourceRoot":""}