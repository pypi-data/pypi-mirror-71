{"version":3,"file":"chunk.a3b26a639688056bebd3.js","sources":["webpack:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js"],"sourcesContent":["export class VirtualRepeater {\n    constructor(config) {\n        /**\n         * Invoked when a new (not recycled) child needs to be displayed.\n         * Set by createElement.\n         */\n        this._createElementFn = null;\n        /**\n         * Invoked on new (including recycled) children after the range changes.\n         * Set by updateElement.\n         */\n        this._updateElementFn = null;\n        /**\n         * Invoked on outgoing children after the range changes. Set by recycleElement.\n         */\n        this._recycleElementFn = null;\n        /**\n         * Used for generating a key for storing references to children. Set by elementKey.\n         */\n        this._elementKeyFn = null;\n        /**\n         * Items to render. Set by items.\n         */\n        this._items = [];\n        /**\n         * Total number of items to render. Set by totalItems.\n         */\n        this._totalItems = null;\n        /**\n         * Flag for asynchnronous reset requests. Resetting clears and reinserts\n         * children in the range.\n         */\n        this._needsReset = false;\n        /**\n         * Flag for asynchnronous remeasure requests. Signals that all children\n         * should be remeasured.\n         */\n        this._needsRemeasure = false;\n        /**\n         * Used to keep track of children that can be cleaned up after a range update.\n         */\n        this._active = new Map();\n        this._prevActive = new Map();\n        /**\n         * Used for recycling purposes.\n         */\n        this._keyToChild = new Map();\n        this._childToKey = new WeakMap();\n        /**\n         * Used to keep track of measures by index.\n         */\n        this._indexToMeasure = {};\n        this.__incremental = false;\n        /**\n         * Invoked at the end of each render cycle: children in the range are\n         * measured, and their dimensions passed to this callback. Use it to layout\n         * children as needed.\n         */\n        this._measureCallback = null;\n        /**\n         * Number of children in the range. Set by num.\n         * TODO @straversi: Consider renaming this. count? visibleElements?\n         */\n        this._num = Infinity;\n        /**\n         * Index of the first child in the range, not necessarily the first visible child.\n         * TODO @straversi: Consider renaming these.\n         */\n        this._first = 0;\n        /**\n         * Index of the last child in the range.\n         */\n        this._last = 0;\n        /**\n         * Previous first rendered index. Used to avoid unnecessary updates.\n         */\n        this._prevFirst = 0;\n        /**\n         * Previous last rendered index. Used to avoid unnecessary updates.\n         */\n        this._prevLast = 0;\n        /**\n         * Flag for asynchnronous render requests. Renders can be requested several\n         * times before a render actually happens.\n         */\n        this._pendingRender = null;\n        /**\n         * Containing element. Set by container.\n         */\n        this._container = null;\n        /**\n         * Children in the rendered order.\n         */\n        this._ordered = [];\n        if (config) {\n            Object.assign(this, config);\n        }\n    }\n    // API\n    /**\n     * The parent of all child nodes to be rendered.\n     */\n    get container() {\n        return this._container;\n    }\n    set container(container) {\n        if (container === this._container) {\n            return;\n        }\n        if (this._container) {\n            // Remove children from old container.\n            this._ordered.forEach((child) => this._removeChild(child));\n        }\n        this._container = container;\n        if (container) {\n            // Insert children in new container.\n            this._ordered.forEach((child) => this._insertBefore(child, null));\n        }\n        else {\n            this._ordered.length = 0;\n            this._active.clear();\n            this._prevActive.clear();\n        }\n        this.requestReset();\n    }\n    /**\n     * Invoked to create a child.\n     * Override or set directly to control element creation.\n     */\n    get createElement() {\n        return this._createElementFn;\n    }\n    set createElement(fn) {\n        if (fn !== this._createElementFn) {\n            this._createElementFn = fn;\n            this._keyToChild.clear();\n            this.requestReset();\n        }\n    }\n    /**\n     * Invoked to update a child.\n     * Override or set directly to control element updates.\n     */\n    get updateElement() {\n        return this._updateElementFn;\n    }\n    set updateElement(fn) {\n        if (fn !== this._updateElementFn) {\n            this._updateElementFn = fn;\n            this.requestReset();\n        }\n    }\n    /**\n     * Invoked in place of removing a child from the DOM, so that it can be reused.\n     * Override or set directly to prepare children for reuse.\n     */\n    get recycleElement() {\n        return this._recycleElementFn;\n    }\n    set recycleElement(fn) {\n        if (fn !== this._recycleElementFn) {\n            this._recycleElementFn = fn;\n            this.requestReset();\n        }\n    }\n    /**\n     * Invoked to generate a key for an element.\n     * Override or set directly to control how keys are generated for children.\n     */\n    get elementKey() {\n        return this._elementKeyFn;\n    }\n    set elementKey(fn) {\n        if (fn !== this._elementKeyFn) {\n            this._elementKeyFn = fn;\n            this._keyToChild.clear();\n            this.requestReset();\n        }\n    }\n    /**\n     * The index of the first child in the range.\n     */\n    get first() {\n        return this._first;\n    }\n    set first(idx) {\n        if (typeof idx !== 'number') {\n            throw new Error('New value must be a number.');\n        }\n        const newFirst = Math.max(0, Math.min(idx, this.totalItems - this._num));\n        if (newFirst !== this._first) {\n            this._first = newFirst;\n            this._scheduleRender();\n        }\n    }\n    /**\n     * The number of children in the range.\n     */\n    get num() {\n        return this._num;\n    }\n    set num(n) {\n        if (typeof n !== 'number') {\n            throw new Error('New value must be a number.');\n        }\n        if (n !== this._num) {\n            this._num = n;\n            this.first = this._first;\n            this._scheduleRender();\n        }\n    }\n    /**\n     * An array of data to be used to render child nodes.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        if (items !== this._items && Array.isArray(items)) {\n            this._items = items;\n            this.requestReset();\n        }\n    }\n    /**\n     * The total number of items, regardless of the range, that can be rendered\n     * as child nodes.\n     */\n    get totalItems() {\n        return (this._totalItems === null ? this._items.length : this._totalItems);\n    }\n    set totalItems(num) {\n        if (typeof num !== 'number' && num !== null) {\n            throw new Error('New value must be a number.');\n        }\n        // TODO(valdrin) should we check if it is a finite number?\n        // Technically, Infinity would break Layout, not VirtualRepeater.\n        if (num !== this._totalItems) {\n            this._totalItems = num;\n            this.first = this._first;\n            this.requestReset();\n        }\n    }\n    /**\n     * TODO @straversi: Document this.\n     */\n    get _incremental() {\n        return this.__incremental;\n    }\n    set _incremental(inc) {\n        if (inc !== this.__incremental) {\n            this.__incremental = inc;\n            this._scheduleRender();\n        }\n    }\n    /**\n     * Invoke to request that all elements in the range be measured.\n     */\n    requestRemeasure() {\n        this._needsRemeasure = true;\n        this._scheduleRender();\n    }\n    // Core functionality\n    _shouldRender() {\n        return Boolean(this.container && this.createElement);\n    }\n    /**\n     * Render at the next opportunity.\n     */\n    async _scheduleRender() {\n        if (!this._pendingRender) {\n            this._pendingRender = true;\n            await Promise.resolve();\n            this._pendingRender = false;\n            if (this._shouldRender()) {\n                this._render();\n            }\n            // this._pendingRender = requestAnimationFrame(() => {\n            //   this._pendingRender = null;\n            //   if (this._shouldRender()) {\n            //     this._render();\n            //   }\n            // });\n        }\n    }\n    /**\n     * Invoke to request that all elements in the range be updated.\n     */\n    requestReset() {\n        this._needsReset = true;\n        this._scheduleRender();\n    }\n    /**\n     * Returns those children that are about to be displayed and that require to\n     * be positioned. If reset or remeasure has been triggered, all children are\n     * returned.\n     */\n    get _toMeasure() {\n        return this._ordered.reduce((toMeasure, c, i) => {\n            const idx = this._first + i;\n            if (this._needsReset || this._needsRemeasure || idx < this._prevFirst ||\n                idx > this._prevLast) {\n                toMeasure.indices.push(idx);\n                toMeasure.children.push(c);\n            }\n            return toMeasure;\n        }, { indices: [], children: [] });\n    }\n    /**\n     * Measures each child bounds and builds a map of index/bounds to be passed\n     * to the `_measureCallback`\n     */\n    async _measureChildren({ indices, children }) {\n        await (new Promise((resolve) => {\n            requestAnimationFrame(resolve);\n        }));\n        const pm = children.map((c) => this._measureChild(c));\n        const mm = /** @type {{number: {width: number, height: number}}} */ (pm.reduce((out, cur, i) => {\n            out[indices[i]] = this._indexToMeasure[indices[i]] = cur;\n            return out;\n        }, {}));\n        this._measureCallback(mm);\n    }\n    /**\n     * Render items within the current range to the DOM.\n     */\n    async _render() {\n        const rangeChanged = this._first !== this._prevFirst || this._num !== this._prevNum;\n        // Create/update/recycle DOM.\n        if (rangeChanged || this._needsReset) {\n            this._last =\n                this._first + Math.min(this._num, this.totalItems - this._first) - 1;\n            if (this._num || this._prevNum) {\n                if (this._needsReset) {\n                    this._reset(this._first, this._last);\n                }\n                else {\n                    // Remove old children and insert new children without touching\n                    // shared children.\n                    this._discardHead();\n                    this._discardTail();\n                    this._addHead();\n                    this._addTail();\n                }\n            }\n        }\n        if (this._needsRemeasure || this._needsReset) {\n            this._indexToMeasure = {};\n        }\n        // Retrieve DOM to be measured.\n        // Do it right before cleanup and reset of properties.\n        const shouldMeasure = this._num > 0 && this._measureCallback &&\n            (rangeChanged || this._needsRemeasure || this._needsReset);\n        const toMeasure = shouldMeasure ? this._toMeasure : null;\n        // Cleanup.\n        if (!this._incremental) {\n            this._prevActive.forEach((idx, child) => this._unassignChild(child, idx));\n            this._prevActive.clear();\n        }\n        // Reset internal properties.\n        this._prevFirst = this._first;\n        this._prevLast = this._last;\n        this._prevNum = this._num;\n        this._needsReset = false;\n        this._needsRemeasure = false;\n        // Notify render completed.\n        this._didRender();\n        // Measure DOM.\n        if (toMeasure) {\n            await this._measureChildren(toMeasure);\n        }\n    }\n    /**\n     * Invoked after DOM is updated, and before it gets measured.\n     */\n    _didRender() {\n    }\n    /**\n     * Unassigns any children at indices lower than the start of the current\n     * range.\n     */\n    _discardHead() {\n        const o = this._ordered;\n        for (let idx = this._prevFirst; o.length && idx < this._first; idx++) {\n            this._unassignChild(o.shift(), idx);\n        }\n    }\n    /**\n     * Unassigns any children at indices higher than the end of the current\n     * range.\n     */\n    _discardTail() {\n        const o = this._ordered;\n        for (let idx = this._prevLast; o.length && idx > this._last; idx--) {\n            this._unassignChild(o.pop(), idx);\n        }\n    }\n    /**\n     * Assigns and inserts non-existent children from the current range with\n     * indices lower than the start of the previous range.\n     */\n    _addHead() {\n        const start = this._first;\n        const end = Math.min(this._last, this._prevFirst - 1);\n        for (let idx = end; idx >= start; idx--) {\n            const child = this._assignChild(idx);\n            // Maintain dom order.\n            this._insertBefore(child, this._firstChild);\n            if (this.updateElement) {\n                this.updateElement(child, this._items[idx], idx);\n            }\n            this._ordered.unshift(child);\n        }\n    }\n    /**\n     * Assigns and appends non-existent children from the current range with\n     * indices higher than the end of the previous range.\n     */\n    _addTail() {\n        const start = Math.max(this._first, this._prevLast + 1);\n        const end = this._last;\n        for (let idx = start; idx <= end; idx++) {\n            const child = this._assignChild(idx);\n            // Maintain dom order.\n            this._insertBefore(child, null);\n            if (this.updateElement) {\n                this.updateElement(child, this._items[idx], idx);\n            }\n            this._ordered.push(child);\n        }\n    }\n    /**\n     * Re-insert and update children in the given range.\n     */\n    _reset(first, last) {\n        // Swapping prevActive with active affects _assignChild.\n        // Upon resetting, the current active children become potentially inactive.\n        // _assignChild will remove a child from _prevActive if it is still active.\n        const prevActive = this._active;\n        this._active = this._prevActive;\n        this._prevActive = prevActive;\n        this._ordered.length = 0;\n        let currentMarker = this._firstChild;\n        for (let i = first; i <= last; i++) {\n            const child = this._assignChild(i);\n            this._ordered.push(child);\n            if (currentMarker) {\n                if (currentMarker === this._node(child)) {\n                    currentMarker = this._nextSibling(child);\n                }\n                else {\n                    this._insertBefore(child, currentMarker);\n                }\n            }\n            else if (!this._childIsAttached(child)) {\n                this._insertBefore(child, null);\n            }\n            if (this.updateElement) {\n                this.updateElement(child, this._items[i], i);\n            }\n        }\n    }\n    /**\n     * Instantiates, tracks, and returns the child at idx.\n     * Prevents cleanup of children that already exist.\n     * Returns the new child at idx.\n     */\n    _assignChild(idx) {\n        const key = this.elementKey ? this.elementKey(idx) : idx;\n        let child;\n        if (child = this._keyToChild.get(key)) {\n            this._prevActive.delete(child);\n        }\n        else {\n            child = this.createElement(this._items[idx], idx);\n            this._keyToChild.set(key, child);\n            this._childToKey.set(child, key);\n        }\n        this._showChild(child);\n        this._active.set(child, idx);\n        return child;\n    }\n    /**\n     * Removes the child at idx, recycling it if possible.\n     */\n    _unassignChild(child, idx) {\n        this._hideChild(child);\n        if (this._incremental) {\n            this._active.delete(child);\n            this._prevActive.set(child, idx);\n        }\n        else {\n            const key = this._childToKey.get(child);\n            this._childToKey.delete(child);\n            this._keyToChild.delete(key);\n            this._active.delete(child);\n            if (this.recycleElement) {\n                this.recycleElement(child, idx);\n            }\n            else if (this._node(child).parentNode) {\n                this._removeChild(child);\n            }\n        }\n    }\n    /**\n     * Returns the node for the first child in the current range, if the node is\n     * in the DOM.\n     * TODO: Is this the right name?\n     */\n    get _firstChild() {\n        return this._ordered.length && this._childIsAttached(this._ordered[0]) ?\n            this._node(this._ordered[0]) :\n            null;\n    }\n    /**\n     * Overridable abstractions for child manipulation\n     */\n    /**\n     * Return the node for child.\n     * Override if child !== child's node.\n     */\n    _node(child) {\n        return child;\n    }\n    /**\n     * Returns the next node sibling of a child node.\n     */\n    _nextSibling(child) {\n        return child.nextSibling;\n    }\n    /**\n     * Inserts child before referenceNode in the container.\n     * Override to control child insertion.\n     */\n    _insertBefore(child, referenceNode) {\n        this._container.insertBefore(child, referenceNode);\n    }\n    /**\n     * Removes child from the DOM.\n     * TODO @straversi: this will not work (_node should be called on child), but\n     * is not currently being used or tested.\n     */\n    _removeChild(child) {\n        child.parentNode.removeChild(child);\n    }\n    /**\n     * Returns whether the child's node is a child of the container\n     * element.\n     */\n    _childIsAttached(child) {\n        const node = this._node(child);\n        return node && node.parentNode === this._container;\n    }\n    /**\n     * Sets the display style of the given node to 'none'.\n     */\n    _hideChild(child) {\n        if (child instanceof HTMLElement) {\n            child.style.display = 'none';\n        }\n    }\n    /**\n     * Sets the display style of the given node to null.\n     */\n    _showChild(child) {\n        if (child instanceof HTMLElement) {\n            child.style.display = null;\n        }\n    }\n    /**\n     * Returns the width, height, and margins of the given child.\n     * Override if child !== child's node.\n     */\n    _measureChild(child) {\n        // offsetWidth doesn't take transforms in consideration, so we use\n        // getBoundingClientRect which does.\n        const { width, height } = child.getBoundingClientRect();\n        return Object.assign({ width, height }, getMargins(child));\n    }\n}\nfunction getMargins(el) {\n    const style = window.getComputedStyle(el);\n    return {\n        marginTop: getMarginValue(style.marginTop),\n        marginRight: getMarginValue(style.marginRight),\n        marginBottom: getMarginValue(style.marginBottom),\n        marginLeft: getMarginValue(style.marginLeft),\n    };\n}\nfunction getMarginValue(value) {\n    const float = value ? parseFloat(value) : NaN;\n    return Number.isNaN(float) ? 0 : float;\n}\n"],"mappings":"AAAA","sourceRoot":""}