{"version":3,"file":"chunk.166f99573485115d59af.js","sources":["webpack:///./node_modules/idb-keyval/dist/idb-keyval.mjs","webpack:///./src/components/ha-svg-icon.ts","webpack:///./src/components/ha-icon.ts","webpack:///./node_modules/@polymer/iron-icon/iron-icon.js","webpack:///./src/dialogs/config-flow/show-dialog-config-flow.ts","webpack:///./src/onboarding/action-badge.ts","webpack:///./src/onboarding/integration-badge.ts","webpack:///./src/onboarding/onboarding-integrations.ts"],"sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import {\n  css,\n  CSSResult,\n  customElement,\n  LitElement,\n  property,\n  svg,\n  SVGTemplateResult,\n} from \"lit-element\";\n\n@customElement(\"ha-svg-icon\")\nexport class HaSvgIcon extends LitElement {\n  @property() public path?: string;\n\n  @property() public viewBox?: string;\n\n  protected render(): SVGTemplateResult {\n    return svg`\n    <svg \n      viewBox=${this.viewBox || \"0 0 24 24\"}\n      preserveAspectRatio=\"xMidYMid meet\"\n      focusable=\"false\">\n      <g>\n      ${this.path ? svg`<path d=${this.path}></path>` : \"\"}\n      </g>\n    </svg>`;\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: var(--ha-icon-display, inline-flex);\n        align-items: center;\n        justify-content: center;\n        position: relative;\n        vertical-align: middle;\n        fill: currentcolor;\n        width: var(--mdc-icon-size, 24px);\n        height: var(--mdc-icon-size, 24px);\n      }\n      svg {\n        width: 100%;\n        height: 100%;\n        pointer-events: none;\n        display: block;\n      }\n    `;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-svg-icon\": HaSvgIcon;\n  }\n}\n","import \"@polymer/iron-icon/iron-icon\";\nimport {\n  customElement,\n  LitElement,\n  property,\n  PropertyValues,\n  html,\n  TemplateResult,\n  css,\n  CSSResult,\n} from \"lit-element\";\nimport \"./ha-svg-icon\";\nimport { customIconsets, CustomIcon } from \"../data/custom_iconsets\";\nimport {\n  Chunks,\n  MDI_PREFIXES,\n  getIcon,\n  findIconChunk,\n  Icons,\n  checkCacheVersion,\n  writeCache,\n} from \"../data/iconsets\";\nimport { debounce } from \"../common/util/debounce\";\n\nconst chunks: Chunks = {};\n\ncheckCacheVersion();\n\nconst debouncedWriteCache = debounce(() => writeCache(chunks), 2000);\n\nconst cachedIcons: { [key: string]: string } = {};\n\n@customElement(\"ha-icon\")\nexport class HaIcon extends LitElement {\n  @property() public icon?: string;\n\n  @property() private _path?: string;\n\n  @property() private _viewBox?;\n\n  @property() private _legacy = false;\n\n  protected updated(changedProps: PropertyValues) {\n    if (changedProps.has(\"icon\")) {\n      this._path = undefined;\n      this._viewBox = undefined;\n      this._loadIcon();\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.icon) {\n      return html``;\n    }\n    if (this._legacy) {\n      return html`<iron-icon .icon=${this.icon}></iron-icon>`;\n    }\n    return html`<ha-svg-icon\n      .path=${this._path}\n      .viewBox=${this._viewBox}\n    ></ha-svg-icon>`;\n  }\n\n  private async _loadIcon() {\n    if (!this.icon) {\n      return;\n    }\n    const [iconPrefix, iconName] = this.icon.split(\":\", 2);\n\n    if (!iconPrefix || !iconName) {\n      return;\n    }\n\n    if (!MDI_PREFIXES.includes(iconPrefix)) {\n      if (iconPrefix in customIconsets) {\n        const customIconset = customIconsets[iconPrefix];\n        if (customIconset) {\n          this._setCustomPath(customIconset(iconName));\n        }\n        return;\n      }\n      this._legacy = true;\n      return;\n    }\n\n    this._legacy = false;\n\n    if (iconName in cachedIcons) {\n      this._path = cachedIcons[iconName];\n      return;\n    }\n\n    let databaseIcon: string | undefined;\n    try {\n      databaseIcon = await getIcon(iconName);\n    } catch (_err) {\n      // Firefox in private mode doesn't support IDB\n      databaseIcon = undefined;\n    }\n\n    if (databaseIcon) {\n      this._path = databaseIcon;\n      cachedIcons[iconName] = databaseIcon;\n      return;\n    }\n    const chunk = findIconChunk(iconName);\n\n    if (chunk in chunks) {\n      this._setPath(chunks[chunk], iconName);\n      return;\n    }\n    const iconPromise = fetch(`/static/mdi/${chunk}.json`).then((response) =>\n      response.json()\n    );\n    chunks[chunk] = iconPromise;\n    this._setPath(iconPromise, iconName);\n    debouncedWriteCache();\n  }\n\n  private async _setCustomPath(promise: Promise<CustomIcon>) {\n    const icon = await promise;\n    this._path = icon.path;\n    this._viewBox = icon.viewBox;\n  }\n\n  private async _setPath(promise: Promise<Icons>, iconName: string) {\n    const iconPack = await promise;\n    this._path = iconPack[iconName];\n    cachedIcons[iconName] = iconPack[iconName];\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        fill: currentcolor;\n      }\n    `;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon\": HaIcon;\n  }\n}\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\n\nimport {IronMeta} from '@polymer/iron-meta/iron-meta.js';\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\nimport {Base} from '@polymer/polymer/polymer-legacy.js';\n\n/**\n\nThe `iron-icon` element displays an icon. By default an icon renders as a 24px\nsquare.\n\nExample using src:\n\n    <iron-icon src=\"star.png\"></iron-icon>\n\nExample setting size to 32px x 32px:\n\n    <iron-icon class=\"big\" src=\"big_star.png\"></iron-icon>\n\n    <style is=\"custom-style\">\n      .big {\n        --iron-icon-height: 32px;\n        --iron-icon-width: 32px;\n      }\n    </style>\n\nThe iron elements include several sets of icons. To use the default set of\nicons, import `iron-icons.js` and use the `icon` attribute to specify an icon:\n\n    <script type=\"module\">\n      import \"@polymer/iron-icons/iron-icons.js\";\n    </script>\n\n    <iron-icon icon=\"menu\"></iron-icon>\n\nTo use a different built-in set of icons, import the specific\n`iron-icons/<iconset>-icons.js`, and specify the icon as `<iconset>:<icon>`.\nFor example, to use a communication icon, you would use:\n\n    <script type=\"module\">\n      import \"@polymer/iron-icons/communication-icons.js\";\n    </script>\n\n    <iron-icon icon=\"communication:email\"></iron-icon>\n\nYou can also create custom icon sets of bitmap or SVG icons.\n\nExample of using an icon named `cherry` from a custom iconset with the ID\n`fruit`:\n\n    <iron-icon icon=\"fruit:cherry\"></iron-icon>\n\nSee `<iron-iconset>` and `<iron-iconset-svg>` for more information about how to\ncreate a custom iconset.\n\nSee the `iron-icons` demo to see the icons available in the various iconsets.\n\n### Styling\n\nThe following custom properties are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--iron-icon` | Mixin applied to the icon | {}\n`--iron-icon-width` | Width of the icon | `24px`\n`--iron-icon-height` | Height of the icon | `24px`\n`--iron-icon-fill-color` | Fill color of the svg icon | `currentcolor`\n`--iron-icon-stroke-color` | Stroke color of the svg icon | none\n\n@group Iron Elements\n@element iron-icon\n@demo demo/index.html\n@hero hero.svg\n@homepage polymer.github.io\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        @apply --layout-inline;\n        @apply --layout-center-center;\n        position: relative;\n\n        vertical-align: middle;\n\n        fill: var(--iron-icon-fill-color, currentcolor);\n        stroke: var(--iron-icon-stroke-color, none);\n\n        width: var(--iron-icon-width, 24px);\n        height: var(--iron-icon-height, 24px);\n        @apply --iron-icon;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n    </style>\n`,\n\n  is: 'iron-icon',\n\n  properties: {\n\n    /**\n     * The name of the icon to use. The name should be of the form:\n     * `iconset_name:icon_name`.\n     */\n    icon: {type: String},\n\n    /**\n     * The name of the theme to used, if one is specified by the\n     * iconset.\n     */\n    theme: {type: String},\n\n    /**\n     * If using iron-icon without an iconset, you can set the src to be\n     * the URL of an individual icon image file. Note that this will take\n     * precedence over a given icon attribute.\n     */\n    src: {type: String},\n\n    /**\n     * @type {!IronMeta}\n     */\n    _meta: {value: Base.create('iron-meta', {type: 'iconset'})}\n\n  },\n\n  observers: [\n    '_updateIcon(_meta, isAttached)',\n    '_updateIcon(theme, isAttached)',\n    '_srcChanged(src, isAttached)',\n    '_iconChanged(icon, isAttached)'\n  ],\n\n  _DEFAULT_ICONSET: 'icons',\n\n  _iconChanged: function(icon) {\n    var parts = (icon || '').split(':');\n    this._iconName = parts.pop();\n    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;\n    this._updateIcon();\n  },\n\n  _srcChanged: function(src) {\n    this._updateIcon();\n  },\n\n  _usesIconset: function() {\n    return this.icon || !this.src;\n  },\n\n  /** @suppress {visibility} */\n  _updateIcon: function() {\n    if (this._usesIconset()) {\n      if (this._img && this._img.parentNode) {\n        dom(this.root).removeChild(this._img);\n      }\n      if (this._iconName === '') {\n        if (this._iconset) {\n          this._iconset.removeIcon(this);\n        }\n      } else if (this._iconsetName && this._meta) {\n        this._iconset = /** @type {?Polymer.Iconset} */ (\n            this._meta.byKey(this._iconsetName));\n        if (this._iconset) {\n          this._iconset.applyIcon(this, this._iconName, this.theme);\n          this.unlisten(window, 'iron-iconset-added', '_updateIcon');\n        } else {\n          this.listen(window, 'iron-iconset-added', '_updateIcon');\n        }\n      }\n    } else {\n      if (this._iconset) {\n        this._iconset.removeIcon(this);\n      }\n      if (!this._img) {\n        this._img = document.createElement('img');\n        this._img.style.width = '100%';\n        this._img.style.height = '100%';\n        this._img.draggable = false;\n      }\n      this._img.src = this.src;\n      dom(this.root).appendChild(this._img);\n    }\n  }\n});\n","import { html } from \"lit-element\";\nimport { caseInsensitiveCompare } from \"../../common/string/compare\";\nimport { localizeKey } from \"../../common/translations/localize\";\nimport {\n  createConfigFlow,\n  deleteConfigFlow,\n  fetchConfigFlow,\n  getConfigFlowHandlers,\n  handleConfigFlowStep,\n} from \"../../data/config_flow\";\nimport { domainToName } from \"../../data/integration\";\nimport {\n  DataEntryFlowDialogParams,\n  loadDataEntryFlowDialog,\n  showFlowDialog,\n} from \"./show-dialog-data-entry-flow\";\n\nexport const loadConfigFlowDialog = loadDataEntryFlowDialog;\n\nexport const showConfigFlowDialog = (\n  element: HTMLElement,\n  dialogParams: Omit<DataEntryFlowDialogParams, \"flowConfig\">\n): void =>\n  showFlowDialog(element, dialogParams, {\n    loadDevicesAndAreas: true,\n    getFlowHandlers: async (hass) => {\n      const [handlers] = await Promise.all([\n        getConfigFlowHandlers(hass),\n        hass.loadBackendTranslation(\"title\", undefined, true),\n      ]);\n\n      return handlers.sort((handlerA, handlerB) =>\n        caseInsensitiveCompare(\n          domainToName(hass.localize, handlerA),\n          domainToName(hass.localize, handlerB)\n        )\n      );\n    },\n    createFlow: async (hass, handler) => {\n      const [step] = await Promise.all([\n        createConfigFlow(hass, handler),\n        hass.loadBackendTranslation(\"config\", handler),\n      ]);\n      return step;\n    },\n    fetchFlow: async (hass, flowId) => {\n      const step = await fetchConfigFlow(hass, flowId);\n      await hass.loadBackendTranslation(\"config\", step.handler);\n      return step;\n    },\n    handleFlowStep: handleConfigFlowStep,\n    deleteFlow: deleteConfigFlow,\n\n    renderAbortDescription(hass, step) {\n      const description = localizeKey(\n        hass.localize,\n        `component.${step.handler}.config.abort.${step.reason}`,\n        step.description_placeholders\n      );\n\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderShowFormStepHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) || hass.localize(`component.${step.handler}.title`)\n      );\n    },\n\n    renderShowFormStepDescription(hass, step) {\n      const description = localizeKey(\n        hass.localize,\n        `component.${step.handler}.config.step.${step.step_id}.description`,\n        step.description_placeholders\n      );\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderShowFormStepFieldLabel(hass, step, field) {\n      return hass.localize(\n        `component.${step.handler}.config.step.${step.step_id}.data.${field.name}`\n      );\n    },\n\n    renderShowFormStepFieldError(hass, step, error) {\n      return hass.localize(`component.${step.handler}.config.error.${error}`);\n    },\n\n    renderExternalStepHeader(hass, step) {\n      return hass.localize(\n        `component.${step.handler}.config.step.${step.step_id}.title`\n      );\n    },\n\n    renderExternalStepDescription(hass, step) {\n      const description = localizeKey(\n        hass.localize,\n        `component.${step.handler}.config.${step.step_id}.description`,\n        step.description_placeholders\n      );\n\n      return html`\n        <p>\n          ${hass.localize(\n            \"ui.panel.config.integrations.config_flow.external_step.description\"\n          )}\n        </p>\n        ${description\n          ? html`\n              <ha-markdown\n                allowsvg\n                breaks\n                .content=${description}\n              ></ha-markdown>\n            `\n          : \"\"}\n      `;\n    },\n\n    renderCreateEntryDescription(hass, step) {\n      const description = localizeKey(\n        hass.localize,\n        `component.${step.handler}.config.create_entry.${\n          step.description || \"default\"\n        }`,\n        step.description_placeholders\n      );\n\n      return html`\n        ${description\n          ? html`\n              <ha-markdown\n                allowsvg\n                breaks\n                .content=${description}\n              ></ha-markdown>\n            `\n          : \"\"}\n        <p>\n          ${hass.localize(\n            \"ui.panel.config.integrations.config_flow.created_config\",\n            \"name\",\n            step.title\n          )}\n        </p>\n      `;\n    },\n  });\n","import {\n  css,\n  CSSResult,\n  customElement,\n  html,\n  LitElement,\n  property,\n  TemplateResult,\n} from \"lit-element\";\nimport \"../components/ha-icon\";\n\n@customElement(\"action-badge\")\nclass ActionBadge extends LitElement {\n  @property() public icon!: string;\n\n  @property() public title!: string;\n\n  @property() public badgeIcon?: string;\n\n  @property({ type: Boolean, reflect: true }) public clickable = false;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"icon\">\n        <ha-icon .icon=${this.icon}></ha-icon>\n        ${this.badgeIcon\n          ? html` <ha-icon class=\"badge\" .icon=${this.badgeIcon}></ha-icon> `\n          : \"\"}\n      </div>\n      <div class=\"title\">${this.title}</div>\n    `;\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: inline-flex;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n\n      :host([clickable]) {\n        color: var(--primary-text-color);\n      }\n\n      .icon {\n        position: relative;\n        box-sizing: border-box;\n        margin: 0 auto 8px;\n        height: 40px;\n        width: 40px;\n        border-radius: 50%;\n        border: 1px solid var(--secondary-text-color);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n\n      :host([clickable]) .icon {\n        border-color: var(--primary-color);\n        border-width: 2px;\n      }\n\n      .badge {\n        position: absolute;\n        color: var(--primary-color);\n        bottom: -5px;\n        right: -5px;\n        background-color: white;\n        border-radius: 50%;\n        width: 18px;\n        display: block;\n        height: 18px;\n      }\n\n      .title {\n        min-height: 2.3em;\n        word-break: break-word;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"action-badge\": ActionBadge;\n  }\n}\n","import {\n  css,\n  CSSResult,\n  customElement,\n  html,\n  LitElement,\n  property,\n  TemplateResult,\n} from \"lit-element\";\nimport \"../components/ha-icon\";\n\n@customElement(\"integration-badge\")\nclass IntegrationBadge extends LitElement {\n  @property() public domain!: string;\n\n  @property() public title!: string;\n\n  @property() public badgeIcon?: string;\n\n  @property({ type: Boolean, reflect: true }) public clickable = false;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"icon\">\n        <img\n          src=\"https://brands.home-assistant.io/${this.domain}/icon.png\"\n          referrerpolicy=\"no-referrer\"\n        />\n        ${this.badgeIcon\n          ? html` <ha-icon class=\"badge\" .icon=${this.badgeIcon}></ha-icon> `\n          : \"\"}\n      </div>\n      <div class=\"title\">${this.title}</div>\n    `;\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: inline-flex;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n\n      :host([clickable]) {\n        color: var(--primary-text-color);\n      }\n\n      img {\n        max-width: 100%;\n        max-height: 100%;\n      }\n\n      .icon {\n        position: relative;\n        margin: 0 auto 8px;\n        height: 40px;\n        width: 40px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n\n      :host([clickable]) .icon {\n      }\n\n      .badge {\n        position: absolute;\n        color: white;\n        bottom: -7px;\n        right: -10px;\n        background-color: var(--label-badge-green);\n        border-radius: 50%;\n        width: 18px;\n        display: block;\n        height: 18px;\n        border: 2px solid white;\n      }\n\n      .title {\n        min-height: 2.3em;\n        word-break: break-word;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"integration-badge\": IntegrationBadge;\n  }\n}\n","import \"@material/mwc-button/mwc-button\";\nimport {\n  css,\n  CSSResult,\n  customElement,\n  html,\n  LitElement,\n  property,\n  PropertyValues,\n  TemplateResult,\n} from \"lit-element\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { compare } from \"../common/string/compare\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { ConfigEntry, getConfigEntries } from \"../data/config_entries\";\nimport {\n  getConfigFlowInProgressCollection,\n  localizeConfigFlowTitle,\n  subscribeConfigFlowInProgress,\n} from \"../data/config_flow\";\nimport { DataEntryFlowProgress } from \"../data/data_entry_flow\";\nimport { domainToName } from \"../data/integration\";\nimport {\n  loadConfigFlowDialog,\n  showConfigFlowDialog,\n} from \"../dialogs/config-flow/show-dialog-config-flow\";\nimport { HomeAssistant } from \"../types\";\nimport \"./action-badge\";\nimport \"./integration-badge\";\n\n@customElement(\"onboarding-integrations\")\nclass OnboardingIntegrations extends LitElement {\n  @property() public hass!: HomeAssistant;\n\n  @property() public onboardingLocalize!: LocalizeFunc;\n\n  @property() private _entries?: ConfigEntry[];\n\n  @property() private _discovered?: DataEntryFlowProgress[];\n\n  private _unsubEvents?: () => void;\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this.hass.loadBackendTranslation(\"title\", undefined, true);\n    this._unsubEvents = subscribeConfigFlowInProgress(this.hass, (flows) => {\n      this._discovered = flows;\n      for (const flow of flows) {\n        // To render title placeholders\n        if (flow.context.title_placeholders) {\n          this.hass.loadBackendTranslation(\"config\", flow.handler);\n        }\n      }\n    });\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._unsubEvents) {\n      this._unsubEvents();\n      this._unsubEvents = undefined;\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this._entries || !this._discovered) {\n      return html``;\n    }\n    // Render discovered and existing entries together sorted by localized title.\n    const entries: Array<[string, TemplateResult]> = this._entries.map(\n      (entry) => {\n        const title = domainToName(this.hass.localize, entry.domain);\n        return [\n          title,\n          html`\n            <integration-badge\n              .domain=${entry.domain}\n              .title=${title}\n              badgeIcon=\"hass:check\"\n            ></integration-badge>\n          `,\n        ];\n      }\n    );\n    const discovered: Array<[string, TemplateResult]> = this._discovered.map(\n      (flow) => {\n        const title = localizeConfigFlowTitle(this.hass.localize, flow);\n        return [\n          title,\n          html`\n            <button .flowId=${flow.flow_id} @click=${this._continueFlow}>\n              <integration-badge\n                clickable\n                .domain=${flow.handler}\n                .title=${title}\n              ></integration-badge>\n            </button>\n          `,\n        ];\n      }\n    );\n    const content = [...entries, ...discovered]\n      .sort((a, b) => compare(a[0], b[0]))\n      .map((item) => item[1]);\n\n    return html`\n      <p>\n        ${this.onboardingLocalize(\"ui.panel.page-onboarding.integration.intro\")}\n      </p>\n      <div class=\"badges\">\n        ${content}\n        <button @click=${this._createFlow}>\n          <action-badge\n            clickable\n            title=${this.onboardingLocalize(\n              \"ui.panel.page-onboarding.integration.more_integrations\"\n            )}\n            icon=\"hass:dots-horizontal\"\n          ></action-badge>\n        </button>\n      </div>\n      <div class=\"footer\">\n        <mwc-button @click=${this._finish}>\n          ${this.onboardingLocalize(\n            \"ui.panel.page-onboarding.integration.finish\"\n          )}\n        </mwc-button>\n      </div>\n    `;\n  }\n\n  protected firstUpdated(changedProps: PropertyValues) {\n    super.firstUpdated(changedProps);\n    loadConfigFlowDialog();\n    this._loadConfigEntries();\n    /* polyfill for paper-dropdown */\n    import(\n      /* webpackChunkName: \"polyfill-web-animations-next\" */ \"web-animations-js/web-animations-next-lite.min\"\n    );\n  }\n\n  private _createFlow() {\n    showConfigFlowDialog(this, {\n      dialogClosedCallback: () => {\n        this._loadConfigEntries();\n        getConfigFlowInProgressCollection(this.hass!.connection).refresh();\n      },\n    });\n  }\n\n  private _continueFlow(ev) {\n    showConfigFlowDialog(this, {\n      continueFlowId: ev.currentTarget.flowId,\n      dialogClosedCallback: () => {\n        this._loadConfigEntries();\n        getConfigFlowInProgressCollection(this.hass!.connection).refresh();\n      },\n    });\n  }\n\n  private async _loadConfigEntries() {\n    const entries = await getConfigEntries(this.hass!);\n    // We filter out the config entry for the local weather.\n    // It is one that we create automatically and it will confuse the user\n    // if it starts showing up during onboarding.\n    this._entries = entries.filter((entry) => entry.domain !== \"met\");\n  }\n\n  private async _finish() {\n    fireEvent(this, \"onboarding-step\", {\n      type: \"integration\",\n    });\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      .badges {\n        margin-top: 24px;\n        display: flex;\n        flex-direction: row;\n        flex-wrap: wrap;\n        justify-content: flex-start;\n        align-items: flex-start;\n      }\n      .badges > * {\n        width: 96px;\n        margin-bottom: 24px;\n      }\n      button {\n        cursor: pointer;\n        padding: 0;\n        border: 0;\n        background: 0;\n        font: inherit;\n      }\n      .footer {\n        text-align: right;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"onboarding-integrations\": OnboardingIntegrations;\n  }\n}\n"],"mappings":";AAAA;;ACmBA;;;;AAIA;;AAZA;;;;;;;;;;;;;;;;;AAAA;AC+CA;AACA;AAPA;;;;AAnBA;;;;;;;;;;;;;;;;;;;;;AC8EA;ACjDA;AAEA;AAmBA;AAEA;;AA4BA;;AAIA;;;;AAKA;;AAGA;AAIA;AAUA;;;;AAKA;;AAGA;;AAEA;;AC1IA;;AAaA;AACA;;AAIA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AArBA;;;ACaA;;;AAGA;;AAIA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxBA;;ACgEA;AACA;;;AAOA;AAMA;;;AAGA;AACA;;;AAQA;;AAKA;;;AAGA;AACA;;;AAGA;;;;;;AAQA;AACA;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;AApGA","sourceRoot":""}